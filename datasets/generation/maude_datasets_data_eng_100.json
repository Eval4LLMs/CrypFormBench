[
    {
        "file": "MAUDE-1/Denning-Sacco.maude",
        "logic": "---\n\n### Denning Sacco Protocol Description\n\n#### Overview\nThe Denning Sacco Protocol is a cryptographic protocol designed to facilitate secure communication between two users, Alice and Bob, through a trusted server. It employs public key encryption and session keys to ensure confidentiality and authentication during message exchanges.\n\n#### Participants\n1. **Alice (A)**: A user who initiates communication.\n2. **Bob (B)**: A user who receives messages from Alice.\n3. **Server (S)**: A trusted third party that facilitates the key exchange and communication between Alice and Bob.\n\n#### Key Components\n- **Keys**: \n  - **Master Key (mkey)**: A key associated with each user and the server, used for encryption and decryption of messages.\n  - **Session Key (seskey)**: A temporary key generated for a specific session between Alice and Bob.\n- **Nonces**: Random values generated during the protocol execution to ensure freshness and prevent replay attacks.\n- **Messages**: Encrypted and concatenated messages exchanged between the participants.\n\n#### Protocol Steps\n1. **Initial Setup**: \n   - Both Alice and Bob generate their respective Master Keys with the server's help.\n   - The server can derive the Master Key for communication with either Alice or Bob.\n   \n2. **Alice Initiates Communication**:\n   - Alice sends a message to the server containing her identity (A) and Bob's identity (B).\n   - This initiates the process of establishing a session key between Alice and Bob.\n\n3. **Server Responds**:\n   - The server generates a session key for Alice and Bob and sends an encrypted message back to Alice. This message includes:\n     - The session key.\n     - A timestamp (to prevent replay attacks).\n     - An additional encrypted message for Bob.\n\n4. **Bob Receives the Message**:\n   - Bob receives the encrypted message intended for him and uses his Master Key to decrypt it, obtaining the session key and the necessary information to communicate with Alice.\n\n5. **Alice and Bob Communicate**:\n   - After establishing a session key, Alice and Bob can securely exchange messages using this session key, ensuring confidentiality and integrity.\n\n#### Security Properties\n- **Confidentiality**: Messages are encrypted using keys, ensuring that only the intended recipient can read them.\n- **Authentication**: The use of Master Keys allows both users to verify the identity of each other through the server.\n- **Freshness**: Nonces are used to prevent replay attacks by ensuring that old messages cannot be reused in the session.\n\n#### Notation in Maude-NPA\n- `mkey(A, S)`: Denotes the Master Key for Alice with the server.\n- `seskey(A, B, nonce)`: Represents the Session Key for communication between Alice and Bob, with a nonce for freshness.\n- `e(key, message)`: Represents the encryption of a message using a specified key.\n- `d(key, message)`: Represents the decryption of a message using a specified key.\n- Concatenation of messages is denoted by `_ ; _`.\n\nThis structure encompasses the essential elements and processes of the Denning Sacco Protocol, guiding the construction of the corresponding Maude file for simulation and analysis using the Maude-NPA tool.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 12:40:03 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 6866858 in 7848ms cpu (7845ms real) (874981 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh,r':Fresh ::\n[ nil, \n   -(a ; b), \n   +(e(mkey(a, s), b ; seskey(a, b, n(s, r:Fresh)) ; t(s, r':Fresh) ; e(mkey(b,\n    s), a ; seskey(a, b, n(s, r:Fresh)) ; t(s, r':Fresh)))) | nil] \n|| \nseskey(a, b, n(s, r:Fresh)) inI\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,5) .\nrewrites: 22831603 in 26820ms cpu (26822ms real) (851290 rewrites/second)\nresult IdSystemSet: (empty).IdSystemSet\nBye.",
                35.68860983848572
            ]
        ]
    },
    {
        "file": "MAUDE-1/maa-crc.maude",
        "logic": "## Protocol Description\n\n### Overview\nThe protocol defined in the provided Maude file is a cryptographic protocol designed for secure message authentication. The protocol makes use of various cryptographic primitives, including block operations, bitwise operations, and modular arithmetic to compute a Message Authentication Code (MAC). The operations are structured to ensure integrity and authenticity of messages being transmitted.\n\n### Key Components\n1. **Data Types**:\n   - **Bits**: Basic units of information represented by `x0` (0) and `x1` (1).\n   - **Octets**: 8-bit blocks constructed from bits using `buildOctet`.\n   - **Blocks**: Larger data units (composed of multiple octets) constructed with `buildBlock`.\n   - **Messages**: Sequences of blocks that can be constructed using `unitMessage` and `consMessage`.\n   - **Keys**: Cryptographic keys which are constructed from blocks using `buildKey`.\n\n2. **Arithmetic Operations**:\n   - Operations such as addition (`addBit`, `addOctet`, `addBlock`), logical operations (`andBit`, `orBit`, `xorBit`), and comparison operations (`eqBit`, `eqOctet`, etc.) are defined to manipulate bits, octets, and blocks accordingly.\n\n3. **Message Handling**:\n   - Messages can be segmented using `splitSegment` and `cutSegment`, allowing for the transmission of large messages in manageable pieces.\n   - The protocol allows for appending and reversing messages with `appendMessage` and `reverseMessage`.\n\n4. **Cryptographic Functions**:\n   - The core cryptographic functions include `MAA` for computing the MAC, which processes a key and a message to produce a secure output.\n   - The protocol also incorporates functions to adjust and compute various properties of octets and blocks.\n\n5. **Equations and Reductions**:\n   - The protocol includes many equations (e.g., `eq`, `ceq`) that define the behavior of logical and arithmetic operations, ensuring that the relationships between different components are maintained. These equations allow for simplification of expressions and verification of properties.\n\n### Operational Flow\n- The protocol begins with the construction of keys from blocks.\n- Messages are formed and potentially segmented for transmission.\n- The MAC is computed using the key and the message, applying a series of transformations and operations to ensure that the integrity of the message is maintained.\n- The protocol allows for verification of the computed MAC against expected values, utilizing the defined equations to ascertain correctness.\n\n### Security Considerations\n- By leveraging bitwise operations and modular arithmetic, the protocol aims to provide resistance against common cryptographic attacks.\n- The use of various transformations and the combination of multiple operations contribute to the obscurity of the data, making it difficult for unauthorized entities to derive meaningful information.\n\n### Conclusion\nThis protocol is a sophisticated implementation designed to ensure the security of messages transmitted over potentially insecure channels. It encapsulates essential cryptographic techniques and structured operations to maintain data integrity and authenticity throughout the message lifecycle.\n\n### Corresponding Maude File Structure\nTo run this protocol in Maude-NPA, the structure must follow the provided definitions in the Maude file, ensuring all operations, sorts, and equations are correctly defined. The logical flow and security mechanisms described must align with the operational capabilities of the Maude-NPA tool to facilitate verification and validation of the protocol's properties. \n\nThe protocol can be tested and validated against specific scenarios by invoking relevant equations and operations in the Maude-NPA environment, allowing for a thorough examination of its functionality and security guarantees.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 18:59:43 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"maa-crc-command\", line 4: bad token run.\nWarning: \"maa-crc-command\", line 4: no parse for term.\nWarning: \"maa-crc-command\", line 5: bad token initials.\nWarning: \"maa-crc-command\", line 5: no parse for term.",
                0.6283519268035889
            ]
        ]
    },
    {
        "file": "MAUDE-1/Needham_Schroeder_Lowe.maude",
        "logic": "---\n\n### Nedham-Schroeder-Lowe Modified Protocol Description\n\n**Protocol Overview:**\nThe Nedham-Schroeder-Lowe Modified Protocol is a cryptographic protocol designed for secure communication between two parties, Alice (A) and Bob (B), with provisions for nonce generation to prevent replay attacks. The protocol utilizes public-key cryptography for secure message exchanges.\n\n**Participants:**\n- **Alice (A)**: Initiator of the communication.\n- **Bob (B)**: Respondent who receives the initial message from Alice.\n- **Intruder (i)**: An adversary that may attempt to intercept or manipulate the messages exchanged between Alice and Bob.\n\n**Message Structure:**\n- The messages exchanged in the protocol are encrypted using the public keys of the intended recipients:\n  - `pk(B, A ; N_A)` denotes a message encrypted with Bob's public key, containing Alice's identity and a nonce `N_A`.\n  - `pk(A, N_A ; N_B ; B)` denotes a response message encrypted with Alice's public key, containing the nonce `N_A`, a newly generated nonce `N_B`, and Bob's identity.\n  - `pk(B, N_B)` denotes the final message sent by Alice to Bob, containing the nonce `N_B`, encrypted with Bob's public key.\n\n**Nonces:**\n- **N_A**: A nonce generated by Alice.\n- **N_B**: A nonce generated by Bob in response to Alice's initial message. Nonces are crucial for ensuring that each session of communication is unique and helps prevent replay attacks.\n\n**Encryption Scheme:**\n- The protocol employs public-key encryption (denoted by `pk`) and private-key decryption (denoted by `sk`). The following algebraic properties hold:\n  - `pk(K, sk(K, M)) = M`: Decrypting a message M encrypted with a key K using the corresponding private key returns the original message.\n  - `sk(K, pk(K, M)) = M`: Encrypting a message M with a key K and then decrypting it with the same key returns the original message.\n\n**Protocol Steps:**\n1. **Initiation**:\n   - Alice generates a nonce `N_A` and sends the message `pk(B, A ; N_A)` to Bob.\n2. **Response**:\n   - Bob receives Alice's message, decrypts it using his private key, and generates a nonce `N_B`. He then sends the message `pk(A, N_A ; N_B ; B)` back to Alice.\n3. **Completion**:\n   - Alice receives Bob's message, decrypts it using her private key, and sends back the message `pk(B, N_B)` to Bob, confirming the successful exchange of nonces.\n\n**Security Goals:**\n- The protocol aims to achieve mutual authentication between Alice and Bob while ensuring confidentiality through encryption.\n- The use of nonces in the protocol helps to prevent replay attacks and ensures freshness of the messages.\n\n**Intruder Model:**\n- The protocol is designed with the assumption that an intruder may attempt to intercept and manipulate the messages. The defined strands in the protocol specification correspond to both legitimate communication and potential attack scenarios.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 22:48:51 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 4806911 in 4896ms cpu (4894ms real) (981803 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh ::\n[ nil, \n   -(pk(b, a ; N:Nonce)), \n   +(pk(a, N:Nonce ; n(b, r:Fresh) ; b)), \n   -(pk(b, n(b, r:Fresh))) | nil] \n|| \nn(b, r:Fresh) inI\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 7440742 in 9096ms cpu (9096ms real) (818023 rewrites/second)\nresult IdSystemSet: (empty).IdSystemSet\nBye.",
                14.922515392303467
            ]
        ]
    },
    {
        "file": "MAUDE-1/Needham_Schroeder_Lowe_assoc.maude",
        "logic": "### Protocol Description: Modified Needham-Schroeder-Lowe Protocol\n\n#### Participants:\n- **Alice (A)**: The initiator of the protocol.\n- **Bob (B)**: The responder who interacts with Alice.\n- **Intruder (i)**: A malicious entity that may try to intercept or manipulate the messages exchanged between Alice and Bob.\n\n#### Nonces:\n- **N_A**: A nonce generated by Alice.\n- **N_B**: A nonce generated by Bob.\n\n#### Key Concepts:\n- **Public Key (pk)**: The encryption function that uses a public key to encrypt messages.\n- **Private Key (sk)**: The decryption function that uses a private key to decrypt messages.\n- The notation **pk(x,y)** represents the message **y** encrypted with the public key of **x**.\n- The notation **sk(x,y)** represents the message **y** decrypted with the private key of **x**.\n- The algebraic properties governing encryption and decryption are:\n  - **pk(K, sk(K, M)) = M**: Decrypting a message that was encrypted with the corresponding public key yields the original message.\n  - **sk(K, pk(K, M)) = M**: Encrypting a message with the corresponding private key yields the original message.\n\n#### Protocol Steps:\n1. **Step 1**: Alice sends a message to Bob containing her own identity and a nonce encrypted with Bob's public key.\n   - **Message**: `A --> B: pk(B, A ; N_A)`\n   - This message includes Alice's identity (A) and a nonce (N_A) which is used to ensure freshness.\n\n2. **Step 2**: Upon receiving the first message, Bob decrypts it using his private key. He then generates his own nonce (N_B) and sends back a message to Alice that includes Alice's identity, her nonce, his own nonce, and his identity.\n   - **Message**: `B --> A: pk(A, N_A ; N_B ; B)`\n\n3. **Step 3**: Finally, Alice, upon receiving Bob's message, decrypts it to retrieve Bob's nonce and sends a message back to Bob confirming the communication.\n   - **Message**: `A --> B: pk(B, N_B)`\n\n#### Security Objectives:\n- The protocol aims to establish a secure communication channel between Alice and Bob, ensuring that each party can verify the identity of the other and that the messages exchanged are fresh and not replayed by an intruder.\n\n### Maude File Generation\nUsing this description, the Maude file provided encapsulates the key components of the protocol. The structure includes:\n- **Module Definitions**: For symbols, algebraic properties, and the protocol specification.\n- **Strands**: Illustrating the interaction sequences between Alice, Bob, and the intruder.\n- **Attack States**: Representing potential intruder actions or attack scenarios.\n\nThis description can serve as a basis for generating additional Maude files or for further analysis using the Maude-NPA tool.\n\n### Conclusion\nThe modified Needham-Schroeder-Lowe protocol is an important cryptographic protocol that utilizes nonces and public key encryption to secure communications between two parties while preventing impersonation and replay attacks by intruders. The algebraic properties of encryption and decryption ensure that messages can be securely transmitted and verified.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 22:06:28 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 2238152 in 2644ms cpu (2641ms real) (846502 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh ::\n[ nil, \n   -(pk(b, a ; NA:Msg)), \n   +(pk(a, NA:Msg ; n(b, r:Fresh) ; b)), \n   -(pk(b, n(b, r:Fresh))) | nil] \n|| \nn(b, r:Fresh) inI\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 89374 in 48ms cpu (48ms real) (1861958 rewrites/second)\nresult IdSystemSet: (empty).IdSystemSet\nBye.Warning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _;_ is not currently\n    supported.",
                3.5771889686584473
            ]
        ]
    },
    {
        "file": "MAUDE-1/nsl-db-dc.maude",
        "logic": "### Protocol Description: NSL-Distance Bounding Protocol\n\nThe NSL-Distance Bounding (NSL-DB) protocol is designed to mitigate distance-based attacks, particularly the distance hijacking attack, by ensuring that a legitimate party can establish its proximity to another party before engaging in critical communications. The protocol utilizes a combination of nonce challenges, public-key cryptography, and message exchanges to validate the identities of the communicating parties and to prevent intruders from successfully impersonating them.\n\n#### Key Components of the Protocol\n\n1. **Roles**:\n   - **Alice (A)**: Initiator of the protocol who wants to prove her proximity to Bob.\n   - **Bob (B)**: Responder who confirms Alice's proximity and identity.\n   - **Intruder (I)**: An adversary attempting to disrupt or impersonate legitimate parties.\n\n2. **Messages**:\n   - Messages exchanged in the protocol are encrypted and include nonces to prevent replay attacks. Nonces are unique values that are used only once in a session.\n\n3. **Public Key Encryption**:\n   - The protocol employs public and private key pairs (pk and sk) for securing messages. \n   - Each principal has a public key (pk) which is used for encryption, and a corresponding private key (sk) for decryption.\n\n4. **Nonces**:\n   - Nonces are generated during the protocol execution to ensure freshness of the messages and to validate the communication's integrity.\n\n5. **Strands**:\n   - The protocol consists of multiple strands where each strand represents a sequence of actions taken by the principals (Alice and Bob) and the intruder.\n\n6. **Attack Patterns**:\n   - The protocol includes specific attack states to represent potential distance hijacking attacks, allowing the protocol's security properties to be analyzed.\n\n### Protocol Workflow\n\n1. **Initialization**:\n   - The protocol starts with Alice initiating a communication sequence where she sends a message encrypted with Bob's public key, containing a nonce and her identity.\n\n2. **Response**:\n   - Upon receiving Alice's message, Bob responds with a message that includes a nonce and is also encrypted. This message serves as a challenge to Alice.\n\n3. **Challenge-Response**:\n   - Alice must respond to Bob\u2019s challenge by sending back the correct nonce along with her identity, encrypted with Bob\u2019s public key.\n\n4. **Verification**:\n   - Bob verifies Alice's response by decrypting the message and confirming the nonce matches his expectation.\n\n5. **Intrusion Prevention**:\n   - The protocol incorporates measures to detect intruder attempts to impersonate or intercept the communication by introducing additional strands that represent possible attack scenarios.\n\n### Summary\n\nThe NSL-Distance Bounding protocol is structured to ensure secure communication between two legitimate parties while mitigating the risk of distance-related attacks. It leverages cryptographic techniques, nonce challenges, and structured message exchanges to validate the identities of the communicating principals, thereby ensuring that the communication remains secure against potential threats from intruders.\n\n---\n\nThis description can be used to create a corresponding Maude-NPA file that implements the protocol. The details outlined here guide the implementation of the roles, messages, encryption methods, and the structure of the strands in the Maude language, ensuring a coherent representation of the NSL-DB protocol.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 22:47:38 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 5399911 in 6004ms cpu (6004ms real) (899385 rewrites/second)\nresult IdSystem: < 1 > (\n:: r:Fresh ::\n[ nil, \n   +(pk(i, n(a, r:Fresh) ; a)), \n   -(pk(a, n(a, r:Fresh) ; NC:Nonce ; i)), \n   +(pk(i, NC:Nonce)), \n   {init-nsl -> resp-db ;; 1-1 ;; a ; i ; n(a, r:Fresh)} | nil]  & \n:: r'':Fresh ::\n[ nil, \n   {resp-nsl -> init-db ;; 1-1 ;; i ; b ; n(a, r:Fresh)}, \n   +(n(b, r'':Fresh)), \n   -(n(a, r:Fresh) * n(b, r'':Fresh)) | nil] )\n|| empty\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,5) .\nrewrites: 12792782 in 12612ms cpu (12613ms real) (1014334 rewrites/second)\nresult IdSystemSet: (empty).IdSystemSet\nBye.",
                19.556432008743286
            ]
        ]
    },
    {
        "file": "MAUDE-1/signed_dh.maude",
        "logic": "---\n\n### Protocol Description\n\n#### Participants\nThe protocol involves two participants, denoted as A and B. Both participants are assumed to be honest, and they share a secret after executing the protocol.\n\n#### Messages\n1. **First Message from A to B:**\n   - A sends the message: \n     ```\n     A ; B ; exp(g, N_A) ; sign(A, B; exp(g, N_A))\n     ```\n   - Here, `N_A` is a nonce generated by A, `g` is a generator, and `sign(A, B; exp(g, N_A))` represents the signature of A on the message including the exponentiation of `g` to `N_A`.\n\n2. **Response from B to A:**\n   - B replies with:\n     ```\n     A ; B ; exp(g, N_B) ; sign(B, A; exp(g, N_B))\n     ```\n   - Similarly, `N_B` is a nonce generated by B, and `sign(B, A; exp(g, N_B))` is the signature of B on the message including the exponentiation of `g` to `N_B`.\n\n#### Claim\nThe protocol claims the secrecy of the derived message `exp(exp(g, N_B), N_A)` for both A and B, provided that both participants act honestly.\n\n#### Operators and Functions\n- **Exponentiation:** `exp(x, y)` denotes `x` raised to the power of `y`.\n- **Encryption:** `e(K, M)` denotes the encryption of message `M` using key `K`.\n- **Decryption:** `d(K, M)` denotes the decryption of message `M` using key `K`.\n- **Signature:** `sign(Name, Msg)` denotes a digital signature over a message by the specified participant.\n\n#### Algebraic Properties\nThe protocol relies on certain algebraic properties for operations:\n1. **Exponentiation Property:**\n   - `exp(exp(X, Y), Z) = exp(X, Y * Z)`\n   - This property is restricted such that `X` can only take the value of the generator `g`.\n  \n2. **Encryption and Decryption Properties:**\n   - `e(K, d(K, M)) = M`\n   - `d(K, e(K, M)) = M`\n\n#### Knowledge and Intruder Model\nThe model includes an intruder (denoted by `i`), who may have partial knowledge of the secrets and messages being exchanged. The intruder can perform actions such as intercepting messages, attempting to forge signatures, and exploiting the algebraic properties of the cryptographic operations.\n\n### Maude File Structure\nThe Maude file is organized into three modules:\n1. **PROTOCOL-EXAMPLE-SYMBOLS**: Defines the sorts and operations including message types, keys, and cryptographic functions.\n2. **PROTOCOL-EXAMPLE-ALGEBRAIC**: Specifies the algebraic properties of the operations used in the protocol.\n3. **PROTOCOL-SPECIFICATION**: Contains the strands of the protocol, the attack states, and the rules governing the protocol execution.\n\n### Conclusion\nThis protocol is designed to ensure the secrecy of messages exchanged between two honest participants, with the potential for analysis using the Maude-NPA tool to verify its security properties against intruder attacks.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 22:05:58 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in MAUDE-NPA : run(0) .\nrewrites: 3936654 in 4176ms cpu (4176ms real) (942685 rewrites/second)\nresult IdSystem: < 1 > \n:: r:Fresh ::\n[ nil, \n   +(a ; b ; exp(g, n(a, r:Fresh)) ; sign(a, b ; exp(g, n(a, r:Fresh)))), \n   -(a ; b ; XE:Exp ; sign(b, a ; XE:Exp)) | nil] \n|| \nexp(XE:Exp, n(a, r:Fresh)) inI\n|| \nnil\n|| \nnil\n|| \nnil\n==========================================\nreduce in MAUDE-NPA : initials(0,12) .\nrewrites: 5388413 in 7228ms cpu (7229ms real) (745491 rewrites/second)\nresult IdSystemSet: (empty).IdSystemSet\nBye.",
                12.282142162322998
            ]
        ]
    },
    {
        "file": "MAUDE-1/abstract-bakeryAC-checks.maude",
        "logic": "### Abstract Bakery Protocol Description\n\n#### Overview\nThe Abstract Bakery protocol is designed to ensure mutual exclusion among multiple processes (or threads) that need to access a shared resource. The protocol is inspired by the real-world concept of a bakery where customers take a number and wait for their turn to be served. Each process in the protocol follows a series of states to manage its access to the critical section.\n\n#### Components\n1. **States**: \n   - Each process can be in one of three states:\n     - `sleep`: The process is not interested in entering the critical section.\n     - `wait`: The process wants to enter the critical section and is waiting for its turn.\n     - `crit`: The process is currently in the critical section.\n\n2. **Variables**: \n   - Each process `P` and `Q` is associated with a counter that indicates its position in line to enter the critical section. \n   - These counters are represented as natural numbers (Nat), where `0` indicates an absence of interest.\n\n3. **Transitions**: \n   - When a process is in the `sleep` state, it can transition to the `wait` state by incrementing its counter.\n   - When a process is in the `wait` state, it can transition to the `crit` state if it is the next in line.\n   - After executing the critical section, a process returns to the `sleep` state and resets its counter.\n\n4. **Rules**:\n   - There are specific rules that govern transitions between states, ensuring that no two processes can be in the `crit` state simultaneously.\n   - The protocol uses comparisons of counters to manage the order in which processes are allowed to enter the critical section.\n\n#### Properties\n- **Mutual Exclusion**: Only one process can be in the `crit` state at any time.\n- **Progress**: If a process wishes to enter the critical section, it will eventually be able to do so as long as other processes are not holding the critical section indefinitely.\n- **Bounded Waiting**: A process will not have to wait indefinitely to enter the critical section.\n\n#### Maude Representation\nThe protocol is represented in the Maude language using several modules:\n1. **NAT Module**: Defines natural numbers and boolean operations.\n2. **BAKERY Module**: Implements the Bakery protocol with the states and transition rules.\n3. **BAKERY-PREDS Module**: Specifies predicates that characterize the states of processes in relation to their activities (waiting, critical, etc.).\n4. **ABSTRACT-BAKERY Module**: Provides abstractions and equations that simplify the state representation while preserving the essential behavior of the protocol.\n\n### Conclusion\nThe Abstract Bakery protocol offers a model for studying mutual exclusion in concurrent systems. The Maude-NPA tool can be used to analyze the protocol for properties such as termination and confluence, making it a valuable asset in the study of concurrent systems.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Tue May 20 23:28:14 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"abstract-bakeryAC-checks.maude\", line 90: unable to locate file:\n    mfe.maude\nWarning: no loop state.\nWarning: \"maude-npa.maude\", line 16108: bad token init.\nWarning: \"maude-npa.maude\", line 16108: no parse for term.\nWarning: no loop state.\nWarning: \"maude-npa.maude\", line 16108: bad token init.\nWarning: \"maude-npa.maude\", line 16108: no parse for term.\nWarning: no loop state.\nWarning: \"maude-npa.maude\", line 16108: bad token init.\nWarning: \"maude-npa.maude\", line 16108: no parse for term.\nWarning: no loop state.\nWarning: \"maude-npa.maude\", line 16108: bad token init.\nWarning: \"maude-npa.maude\", line 16108: no parse for term.\nWarning: no loop state.\nWarning: \"maude-npa.maude\", line 16108: bad token init.\nWarning: \"maude-npa.maude\", line 16108: no parse for term.\nWarning: \"abstract-bakeryAC-checks-command\", line 4: bad token run.\nWarning: \"abstract-bakeryAC-checks-command\", line 4: no parse for term.\nWarning: \"abstract-bakeryAC-checks-command\", line 5: bad token initials.\nWarning: \"abstract-bakeryAC-checks-command\", line 5: no parse for term.",
                0.6306531429290771
            ]
        ]
    },
    {
        "file": "MAUDE-1/ACU_MissingUnifiersMay2020.maude",
        "logic": "---\n\n### Protocol Description\n\n**Title:** Formal Verification of Addition in Natural Numbers\n\n**Abstract:**\nThis protocol aims to verify properties related to addition in natural numbers and the handling of zero in a formal system using the Maude-NPA tool. The specific focus is on the behavior of addition operations involving natural numbers (`Nat`), non-zero natural numbers (`NzNat`), and zero (`Zero`). The protocol serves as a test case for potential issues in unification processes within the Maude-NPA environment.\n\n**Components:**\n\n1. **Sorts:**\n   - **Zero:** Represents the additive identity in natural numbers.\n   - **NzNat:** Represents non-zero natural numbers.\n   - **Nat:** Represents all natural numbers, which include both zero and non-zero natural numbers.\n\n2. **Subsorts:**\n   - `Zero` and `NzNat` are subsorts of `Nat`, indicating that both types of numbers are part of the broader category of natural numbers.\n\n3. **Operations:**\n   - **Addition (`_+_`):** Two addition operations are defined:\n     - An operation that takes a `Nat` and a `NzNat` and returns a `NzNat`. This operation is associative, commutative, and has an identity element of `0`.\n     - An operation that takes two `Nat` values and returns a `Nat`. This operation is also associative and commutative.\n   - **Zero (`0`):** A constant representing the value of zero in the system.\n   - **Function `g`:** A function that takes a `Zero` and returns a `Nat`. This function is used to demonstrate the relationship between zero and natural numbers.\n\n4. **Unification Test:**\n   - The protocol includes a unification test that attempts to unify a natural number `N` with the result of applying the function `g` to the sum of a natural number `M` and a zero `Z`. This test is crucial for detecting potential issues where unifiers may be incorrectly subsumed by more general unifiers (most general unifiers or MGUs).\n\n**Purpose:**\nThe primary purpose of this protocol is to explore and test the behavior of the Maude-NPA tool in handling addition operations and the implications of zero in arithmetic expressions. The specific scenario tested is a known bug related to losing ACU (associative, commutative, and unifying) unifiers, which can lead to unexpected results in formal proofs and verifications.\n\n**Expected Outcomes:**\nThe protocol aims to highlight the importance of correctly managing unifiers in the presence of zero and to demonstrate how misconfigured flags can affect the detection of issues during unification processes.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 21:21:50 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nunify in FOO : N:Nat =? g(M:Nat + Z:Zero) .\nNo unifier.\nBye.Warning: \"ACU_MissingUnifiersMay2020-command\", line 4: bad token run.\nWarning: \"ACU_MissingUnifiersMay2020-command\", line 4: no parse for term.\nWarning: \"ACU_MissingUnifiersMay2020-command\", line 5: bad token initials.\nWarning: \"ACU_MissingUnifiersMay2020-command\", line 5: no parse for term.",
                0.5778336524963379
            ]
        ]
    },
    {
        "file": "MAUDE-1/ACU_TreeVariableSubproblem.maude",
        "logic": "### Protocol Description for ACU_TreeVariableSubproblem\n\n#### Overview\nThe protocol focuses on corner cases for the `ACU_TreeVariableSubproblem` class, which is concerned with matching subproblems generated by unbound stripper and collector variables. The subjects being analyzed are represented in a red-black tree format, and the main goal is to explore all potential solutions while handling bound variables appropriately.\n\n#### Key Components\n1. **Variables and Operations:**\n   - The protocol uses natural numbers (`Nat`) and defines a sort `Set`, where `Nat` is a subsort of `Set`.\n   - A binary operation `f` is defined, which takes two sets and returns a set, characterized by properties of associativity and commutativity.\n   - A unary operation `g` maps natural numbers to sets, with defined behaviors for base and recursive cases to construct a red-black tree structure.\n   - An operation `h` is defined, which takes two sets and returns a set, with conditional equivalences that govern its behavior based on the values of `N` (the stripper variable).\n\n2. **Corner Cases:**\n   - The protocol examines three distinct scenarios based on the binding of the stripper and collector variables:\n     - **Bound Collector Case:** This scenario analyzes the case where the collector variable is bound, and the equivalences for `h` are conditioned on the value of `N`. Specific conditions include:\n       - When `N > 10`, it captures the value of `M` from the two arguments.\n       - When `N < 2`, it allows for similar behavior.\n       - When `N = 5`, it also allows for capturing `M`.\n     - **Bound Stripper Case:** This scenario focuses on cases where the stripper variable is bound. The equivalence for `h` is defined with conditions on `N`, allowing for the propagation of the collector variable `T` based on the bound stripper `N`.\n     - **Both Bound Case:** Here, both the stripper and collector variables are bound, and the equivalences for `h` are defined to return the collector variable `S` based on conditions on `N`.\n\n#### Example Reductions\nThe protocol includes several examples of reductions to demonstrate its functionality:\n- The reduction `red h(g(11), g(11))` and `red h(f(g(11), g(9)), f(g(11), g(9)))` illustrate cases where the multiplicity of arguments is greater than 1, showcasing how the defined equivalences operate under various conditions.\n\n### Conclusion\nThe Maude file encapsulates a comprehensive analysis of corner cases in the `ACU_TreeVariableSubproblem` with respect to unbound stripper and collector variables. Through careful consideration of the bindings and conditions of these variables, the protocol aims to explore all potential solutions systematically. The provided operations and equivalences validate the behavior of the red-black tree structures within the defined mathematical framework.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 14:29:41 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in FOO : h(g(11), g(11)) .\nrewrites: 25\nresult NzNat: 11\n==========================================\nreduce in FOO : h(f(g(9), g(11)), f(g(9), g(11))) .\nrewrites: 35\nresult NzNat: 11\n==========================================\nreduce in FOO : h(g(11), g(11)) .\nrewrites: 14\nresult Zero: 0\n==========================================\nreduce in FOO : h(f(g(9), g(11)), f(g(9), g(11))) .\nrewrites: 24\nresult Zero: 0\n==========================================\nreduce in FOO : h(g(11), g(11)) .\nrewrites: 13\nresult NzNat: 5\n==========================================\nreduce in FOO : h(f(g(9), g(11)), f(g(9), g(11))) .\nrewrites: 23\nresult NzNat: 5\n==========================================\nreduce in FOO : h(g(11), g(11)) .\nrewrites: 25\nresult Set: f(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n==========================================\nreduce in FOO : h(f(g(9), g(11)), f(g(9), g(11))) .\nrewrites: 35\nresult Set: f(0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10)\n==========================================\nreduce in FOO : h(g(11), g(11)) .\nrewrites: 14\nresult Set: f(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)\n==========================================\nreduce in FOO : h(f(g(9), g(11)), f(g(9), g(11))) .\nrewrites: 24\nresult Set: f(0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 11)\n==========================================\nreduce in FOO : h(g(11), g(11)) .\nrewrites: 13\nresult Set: f(0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11)\n==========================================\nreduce in FOO : h(f(g(9), g(11)), f(g(9), g(11))) .\nrewrites: 23\nresult Set: f(0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 11)\n==========================================\nreduce in FOO : h(g(11), g(11)) .\nrewrites: 25\nresult Set: f(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n==========================================\nreduce in FOO : h(f(g(9), g(11)), f(g(9), g(11))) .\nrewrites: 35\nresult Set: f(0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10)\n==========================================\nreduce in FOO : h(g(11), g(11)) .\nrewrites: 14\nresult Set: f(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)\n==========================================\nreduce in FOO : h(f(g(9), g(11)), f(g(9), g(11))) .\nrewrites: 24\nresult Set: f(0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 11)\n==========================================\nreduce in FOO : h(g(11), g(11)) .\nrewrites: 13\nresult Set: f(0, 1, 2, 3, 4, 6, 7, 8, 9, 10, 11)\n==========================================\nreduce in FOO : h(f(g(9), g(11)), f(g(9), g(11))) .\nrewrites: 23\nresult Set: f(0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 11)\nBye.Warning: \"ACU_TreeVariableSubproblem-command\", line 4: bad token run.\nWarning: \"ACU_TreeVariableSubproblem-command\", line 4: no parse for term.\nWarning: \"ACU_TreeVariableSubproblem-command\", line 5: bad token initials.\nWarning: \"ACU_TreeVariableSubproblem-command\", line 5: no parse for term.",
                0.5786371231079102
            ]
        ]
    },
    {
        "file": "MAUDE-1/ascentFunctionsJanuary2020.maude",
        "logic": "---\n\n### Protocol Description: Non-Existent Module Handling in Maude\n\n#### Overview\nThis protocol is designed to test the behavior of the Maude-NPA tool when dealing with a module that is marked as non-existent. The primary purpose is to ensure that the contents of the `BAD` module cannot be accessed or \"pulled up\" to the metalevel of Maude.\n\n#### Module Definition\n- **Module Name**: `BAD`\n- **Contents**: The `BAD` module is defined to include a placeholder for a nonexistent protocol (denoted by `pr NON-EXISTENT`). This signifies that the module does not contain any functional definitions or operations.\n\n#### Meta-Level Reductions\nThe protocol includes a series of reduction commands at the metalevel to verify that various aspects of the `BAD` module cannot be accessed. Each command attempts to pull specific elements from the `BAD` module to the metalevel and checks that such operations are not permitted.\n\n- **Reductions**:\n  1. **upModule('BAD, false)**: Attempts to promote the `BAD` module to the metalevel.\n  \n  2. **upImports('BAD)**: Attempts to access the imports defined in the `BAD` module.\n  \n  3. **upSorts('BAD, false)**: Attempts to pull up the sorts declared in the `BAD` module.\n  \n  4. **upSubsortDecls('BAD, false)**: Attempts to access the subsort declarations of the `BAD` module.\n  \n  5. **upOpDecls('BAD, false)**: Attempts to pull up the operation declarations from the `BAD` module.\n  \n  6. **upMbs('BAD, false)**: Attempts to access the modules defined in the `BAD` module.\n  \n  7. **upEqs('BAD, false)**: Attempts to pull up the equations defined in the `BAD` module.\n  \n  8. **upRls('BAD, false)**: Attempts to access the rewrite rules defined in the `BAD` module.\n  \n  9. **upStratDecls('BAD, false)**: Attempts to pull up the strategy declarations from the `BAD` module.\n  \n  10. **upSds('BAD, false)**: Attempts to access the structural definitions from the `BAD` module.\n\n#### Expected Outcome\nThe expected outcome of executing this protocol in the Maude-NPA tool is that all the reduction operations will fail or return an error, thereby confirming that the contents of the `BAD` module cannot be accessed at the metalevel.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 18:59:42 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in META-LEVEL : upModule('BAD, false) .\nrewrites: 1\nresult SModule: mod 'BAD is\n  including 'BOOL .\n  protecting 'NON-EXISTENT .\n  sorts none .\n  none\n  none\n  none\n  none\n  none\nendm\n==========================================\nreduce in META-LEVEL : upImports('BAD) .\nrewrites: 1\nresult ImportList: including 'BOOL .\nprotecting 'NON-EXISTENT .\n==========================================\nreduce in META-LEVEL : upSorts('BAD, false) .\nrewrites: 1\nresult EmptyTypeSet: (none).EmptyTypeSet\n==========================================\nreduce in META-LEVEL : upSubsortDecls('BAD, false) .\nrewrites: 1\nresult SubsortDeclSet: (none).SubsortDeclSet\n==========================================\nreduce in META-LEVEL : upOpDecls('BAD, false) .\nrewrites: 1\nresult OpDeclSet: (none).OpDeclSet\n==========================================\nreduce in META-LEVEL : upMbs('BAD, false) .\nrewrites: 1\nresult MembAxSet: (none).MembAxSet\n==========================================\nreduce in META-LEVEL : upEqs('BAD, false) .\nrewrites: 1\nresult EquationSet: (none).EquationSet\n==========================================\nreduce in META-LEVEL : upRls('BAD, false) .\nrewrites: 1\nresult RuleSet: (none).RuleSet\nBye.Warning: \"ascentFunctionsJanuary2020.maude\", line 11 (smod BAD): module\n    NON-EXISTENT does not exist.\nWarning: \"ascentFunctionsJanuary2020.maude\", line 22: bad token upStratDecls.\nWarning: \"ascentFunctionsJanuary2020.maude\", line 22: no parse for term.\nWarning: \"ascentFunctionsJanuary2020.maude\", line 23: bad token upSds.\nWarning: \"ascentFunctionsJanuary2020.maude\", line 23: no parse for term.\nWarning: \"ascentFunctionsJanuary2020-command\", line 4: bad token run.\nWarning: \"ascentFunctionsJanuary2020-command\", line 4: no parse for term.\nWarning: \"ascentFunctionsJanuary2020-command\", line 5: bad token initials.\nWarning: \"ascentFunctionsJanuary2020-command\", line 5: no parse for term.",
                0.5765528678894043
            ]
        ]
    },
    {
        "file": "MAUDE-1/AU_and_A_UnificationEdgeCases.maude",
        "logic": "Based on the provided Maude code snippets, I will generate a descriptive content for the protocol that outlines the various examples and their purposes. This description can then serve as a basis for generating the corresponding Maude file that can be run by Maude-NPA.\n\n---\n\n### Description of the Protocol for Maude-NPA\n\nThis protocol consists of several modules that test edge cases in the associative-identity and associative unification algorithms within the Maude-NPA framework. Each module demonstrates specific scenarios that illustrate the behavior of the unification process under various conditions.\n\n#### Module 1: ASSOC-LIST (Example 1)\n- **Date:** 1/26/21\n- **Purpose:** This module showcases an example where replacing a constrained variable `P` with unconstrained variables `A` and `B` leads to unnecessary incompleteness in the unification process. It highlights issues encountered in versions of the algorithm prior to Alpha133.\n- **Details:** The module defines sorts for elements, pairs, and lists and establishes operations for list concatenation and pair formation. A unification attempt is made with the constrained variable.\n\n#### Module 2: ASSOC-LIST (Example 2)\n- **Date:** 1/27/21\n- **Purpose:** This module demonstrates a corner case where the imperfect splitting of the upper bounds on variables `A`, `B`, and `C` is tightened post hoc to equal upper bounds of `1`. It illustrates the utility of constraint tightening in systems of equations, relying on the `tightenConstraints()` function.\n- **Details:** The module defines additional sorts, including triples, and defines operations for the formation of triples from elements and pairs. A unification attempt is made with variables `T`, `X`, `A`, `B`, and `C`.\n\n#### Module 3: FOO (Example 3)\n- **Date:** 2/18/21\n- **Purpose:** This module demonstrates the Alpha133 optimization that avoids identity assignments in unification cases. It also includes two examples where a sort-decreasing identity axiom disrupts the optimization process.\n- **Details:** The module defines a new sort `Foo` with operations that include an identity element. Two unification attempts are made, one of which is marked as irreducible (irred).\n\n#### Module 4: FOO2 (Example 4)\n- **Date:** 2/18/21\n- **Purpose:** This module continues to explore the Alpha133 optimization, specifically focusing on the avoidance of equality steps and identifying a case where a following equation interferes with the optimization.\n- **Details:** The module introduces two sorts, `Lo` and `Hi`, with operations defined for associative combinations. Unification attempts illustrate the optimization process in action.\n\n#### Module 5: FOO3 (Example 5)\n- **Date:** 2/18/21\n- **Purpose:** This module further investigates the Alpha133 optimization by analyzing cases where the presence of both high and low sorts affects the optimization strategy.\n- **Details:** Similar to previous modules, this one defines operations involving both sorts and explores how they interact during unification attempts.\n\n---\n\nThis description provides a comprehensive overview of the protocol's purpose and structure, allowing for the recreation of the corresponding Maude file for testing with Maude-NPA. Each module serves to highlight particular features and edge cases of the associative unification algorithms and their optimizations.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 22:06:33 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nunify in ASSOC-LIST : P =? A B /\\ X P =? P Y .\n==========================================\nunify in ASSOC-LIST : T X =? A B C Y .\n==========================================\nunify in FOO : W =? Y Z .\n==========================================\nunify in FOO : W =? Y Z .\n==========================================\nunify in FOO2 : W =? Y Z .\n==========================================\nunify in FOO2 : W =? Y Z .\n==========================================\nunify in FOO3 : W =? Y Z .\n==========================================\nunify in FOO3 : W =? Y Z .\n==========================================\nunify in FOO : W X =? Y Z .\n==========================================\nunify in FOO : W =? Y Z .\n==========================================\nunify in FOO : W X =? Y Z /\\ W X =? a a .\n==========================================\nunify in FOO : W X =? Y Z /\\ W X =? a a .\nBye.Warning: Term A B is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: Term T X is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: Term Y Z is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_and_A_UnificationEdgeCases.maude\", line 75: skipped unexpected\n    token: irred\nWarning: Term Y Z is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: Term Y Z is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_and_A_UnificationEdgeCases.maude\", line 86: skipped unexpected\n    token: irred\nWarning: Term Y Z is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: Term Y Z is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_and_A_UnificationEdgeCases.maude\", line 99: skipped unexpected\n    token: irred\nWarning: Term Y Z is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: Term W X is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_and_A_UnificationEdgeCases.maude\", line 116: skipped unexpected\n    token: irred\nWarning: Term Y Z is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: Term W X is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_and_A_UnificationEdgeCases.maude\", line 119: skipped unexpected\n    token: irred\nWarning: Term W X is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_and_A_UnificationEdgeCases-command\", line 4: bad token run.\nWarning: \"AU_and_A_UnificationEdgeCases-command\", line 4: no parse for term.\nWarning: \"AU_and_A_UnificationEdgeCases-command\", line 5: bad token initials.\nWarning: \"AU_and_A_UnificationEdgeCases-command\", line 5: no parse for term.",
                0.678849458694458
            ]
        ]
    },
    {
        "file": "MAUDE-1/AU_IrredUnification.maude",
        "logic": "---\n\n### Description of the Associative-Identity Unification Protocol\n\n#### Overview\n\nThe Associative-Identity Unification (AU) protocol is designed to test the unification of terms under the associative and identity properties. This protocol focuses on irredundant unifiers, which ensures that the number of generated unifiers remains optimized and avoids redundancy. The framework is implemented using the Maude language, facilitating the execution of various unification tests that explore different scenarios involving associative and identity operations.\n\n#### Key Components\n\n1. **Sorts and Operations:**\n   - The protocol defines a sort `Foo` that represents the basic elements involved in unification.\n   - The operation `1` is introduced as the identity element for the associative operation `__`, which combines two elements of type `Foo` in an associative manner.\n   - Additional operations `a`, `b`, and `c` are introduced as constants of type `Foo`.\n\n2. **Variables:**\n   - The protocol employs several variables (`A`, `B`, `C`, `X`, `Y`, `Z`) of type `Foo` to facilitate various unification scenarios.\n\n3. **Unification Scenarios:**\n   - The protocol includes a series of unification tests that demonstrate different cases of irredundant unification, highlighting how the terms can be manipulated under the associative and identity properties.\n   - These scenarios include:\n     - Unifying terms where one side goes to a variable or empty.\n     - Cases where both sides go to a variable or empty.\n     - Situations where the unification completely nulls out under specified conditions.\n     - Handling of null equations and various collapse operations.\n     - Linear unification scenarios where terms are composed of multiple elements.\n\n4. **Order-Sorted Unification:**\n   - The protocol extends to order-sorted unification by defining a hierarchy of sorts (`Elt` and `List`).\n   - The operations include `nil` for an empty list and an associative operation for constructing lists.\n   - Unification tests are performed for elements and lists to explore the implications of order-sorted types.\n\n5. **Cycle Breaking:**\n   - The protocol includes the concept of cycle breaking through various defined sorts, such as `Nat` (natural numbers).\n   - This aspect addresses potential cycles in unification terms to ensure a proper resolution of equations.\n\n6. **Theory Conflicts:**\n   - The protocol tests for conflicts that may arise from the definitions of functions and operations.\n   - This includes scenarios where unification leads to inconsistencies due to the properties of the operations involved.\n\n7. **Non-Disjoint Identities:**\n   - The protocol explores cycle breaking with non-disjoint identities, demonstrating how certain terms can lead to complex unification scenarios.\n\n8. **Sorted and Unsorted MGUs:**\n   - The protocol differentiates between sorted and unsorted most general unifiers (MGUs), showcasing cases where collapse solutions arise due to sorting or type constraints.\n\n#### Conclusion\n\nThe AU protocol encapsulates a comprehensive set of tests for associative-identity unification, emphasizing the importance of optimizing unifiers and addressing various complexities, including cycle breaking and order-sorted types. The modular design of the Maude code allows for easy extension and exploration of new unification scenarios.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 22:48:31 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nunify in AU-TEST : X =? Y X /\\ Z Y =? A B .\n==========================================\nunify in AU-TEST : X =? Y X /\\ Z C =? C /\\ Z Y =? A B .\n==========================================\nunify in AU-TEST : X =? Y X /\\ A C =? C /\\ Z Y =? A B .\n==========================================\nunify in AU-TEST : X =? Y X /\\ Y =? A B Z /\\ Z Y =? A B .\n==========================================\nunify in AU-TEST : X =? 1 /\\ Y =? 1 /\\ Z =? 1 /\\ X =? Y Z .\n==========================================\nunify in AU-TEST : X =? 1 /\\ Y =? 1 /\\ Z =? 1 /\\ X Y =? Y Z .\n==========================================\nunify in AU-TEST : X =? Y X /\\ 1 =? A B Z /\\ Z Y =? A B .\n==========================================\nunify in AU-TEST : X =? Y X /\\ C =? 1 /\\ C =? A B Z /\\ Z Y =? A B .\n==========================================\nunify in AU-TEST : A B C =? a .\n==========================================\nunify in AU-TEST : Y =? 1 /\\ X =? Y Z .\n==========================================\nunify in AU-TEST : A B =? X Y .\n==========================================\nunify in AU-TEST : A B =? X Y Z .\n==========================================\nunify in AU-TEST : A B C =? X Y Z .\n==========================================\nunify in LIST : E =? L M N .\n==========================================\nunify in LIST : E L E M =? E N F N .\n==========================================\nunify in NAT' : X =? s (X * Y) .\n==========================================\nunify in NAT' : X =? s X * Y .\n==========================================\nunify in NAT' : s X =? s X * Y .\n==========================================\nunify in NAT' : s X =? X * Y .\n==========================================\nunify in COMM : X =? c(f(X, Y), Z) .\n==========================================\nunify in FOO2 : X =? f(Y, a, b) /\\ Y =? g(X, c, d) .\n==========================================\nunify in FOO3 : X =? f(Y, a, b) /\\ Y =? h(X) .\n==========================================\nunify in AU-UNSORTED : X:Foo =? f(Y:Foo, Z:Foo) .\n==========================================\nunify in AU-SORTED1 : X:Lo =? f(Y:Hi, Z:Hi) .\n==========================================\nunify in AU-SORTED2 : X:Lo =? f(Y:Hi, Z:Hi) .\nBye.Warning: \"AU_IrredUnification.maude\", line 20: skipped unexpected token: irred\nWarning: Term Y X is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 23: skipped unexpected token: irred\nWarning: Term Y X is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 26: skipped unexpected token: irred\nWarning: Term Y X is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 29: skipped unexpected token: irred\nWarning: Term Y X is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 32: skipped unexpected token: irred\nWarning: Term Y Z is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 33: skipped unexpected token: irred\nWarning: Term X Y is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 36: skipped unexpected token: irred\nWarning: Term Y X is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 37: skipped unexpected token: irred\nWarning: Term Y X is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 40: skipped unexpected token: irred\nWarning: Term A B C is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 41: skipped unexpected token: irred\nWarning: Term Y Z is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 44: skipped unexpected token: irred\nWarning: Term A B is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 45: skipped unexpected token: irred\nWarning: Term A B is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 46: skipped unexpected token: irred\nWarning: Term A B C is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 60: skipped unexpected token: irred\nWarning: Term L M N is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 61: skipped unexpected token: irred\nWarning: Term E L E M is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 78: skipped unexpected token: irred\nWarning: Term X * Y is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 79: skipped unexpected token: irred\nWarning: Term s X * Y is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 82: skipped unexpected token: irred\nWarning: Term s X * Y is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 83: skipped unexpected token: irred\nWarning: Term X * Y is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 94: skipped unexpected token: irred\nWarning: Term f(X, Y) is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"AU_IrredUnification.maude\", line 106: skipped unexpected token: irred\nWarning: Term f(Y, a, b) is non-ground and unification for its top symbol is\n    not currently supported.\nWarning: \"AU_IrredUnification.maude\", line 118: skipped unexpected token: irred\nWarning: Term f(Y, a, b) is non-ground and unification for its top symbol is\n    not currently supported.\nWarning: \"AU_IrredUnification.maude\", line 129: skipped unexpected token: irred\nWarning: Term f(Y:Foo, Z:Foo) is non-ground and unification for its top symbol\n    is not currently supported.\nWarning: \"AU_IrredUnification.maude\", line 139: skipped unexpected token: irred\nWarning: Term f(Y:Hi, Z:Hi) is non-ground and unification for its top symbol is\n    not currently supported.\nWarning: \"AU_IrredUnification.maude\", line 150: skipped unexpected token: irred\nWarning: Term f(Y:Hi, Z:Hi) is non-ground and unification for its top symbol is\n    not currently supported.\nWarning: \"AU_IrredUnification-command\", line 4: bad token run.\nWarning: \"AU_IrredUnification-command\", line 4: no parse for term.\nWarning: \"AU_IrredUnification-command\", line 5: bad token initials.\nWarning: \"AU_IrredUnification-command\", line 5: no parse for term.",
                0.7301661968231201
            ]
        ]
    },
    {
        "file": "MAUDE-1/bank.maude",
        "logic": "### Description of the Banking Protocol\n\n**Protocol Name:** Banking Protocol with Account Management\n\n**Overview:**\nThe banking protocol is designed to manage user accounts, facilitating operations such as crediting, debiting, and transferring funds between accounts. It also includes mechanisms for handling account statuses and limits on the number of accounts.\n\n**Key Components:**\n\n1. **Data Types:**\n   - **Account:** Represents a user account consisting of an identifier, balance, and status.\n   - **Status:** Indicates the state of the account. Possible statuses are \"active\" and \"blocked.\"\n   - **Message:** Represents operations that can be performed on accounts, such as credit, debit, and transfer.\n   - **State:** Represents the overall state of the banking system, including all accounts and operations.\n\n2. **Account Creation and Management:**\n   - Each account is created with an identifier (Id), an initial balance (Int), and a status (Status).\n   - A predefined set of preferred clients (Bob and Charlie) is established, which may have special conditions in the protocol.\n\n3. **Account Operations:**\n   - **Credit:** Increases the account balance of a specified account.\n   - **Debit:** Decreases the account balance of a specified account, which may lead to the account being blocked if the balance goes negative.\n   - **Transfer:** Moves funds from one account to another, adjusting both accounts' balances accordingly.\n\n4. **Initial States:**\n   - The protocol defines multiple initial states (init1, init2, init3) that set up various scenarios with different transactions, allowing for testing of the protocol's behavior under different conditions.\n\n5. **Account Limitations:**\n   - The protocol allows for the creation of new accounts but limits the total number of active accounts to a maximum of 10.\n   - Accounts can be closed if they are blocked and have a balance below a certain negative limit.\n\n6. **Rules and Conditionals:**\n   - The protocol includes rules for updating account statuses based on transactions. For example, if an account balance falls below zero, its status is changed to \"blocked.\"\n   - Additional rules for creating and closing accounts based on the number of existing accounts and account balance are defined.\n\n**Protocol Operations:**\n- `credit(ID, M)`: Credits the account with the identifier `ID` by the amount `M`.\n- `debit(ID, M)`: Debits the account with the identifier `ID` by the amount `M`.\n- `transfer(ID1, ID2, M)`: Transfers the amount `M` from account `ID1` to account `ID2`.\n- `updateStatus(Account)`: Updates the status of an account based on its balance.\n\n**Special Conditions:**\n- Accounts may be flagged as \"blocked\" if their balance falls below zero.\n- Special handling is provided for accounts belonging to preferred clients.\n\nThis protocol can be further extended or modified to include additional features or restrictions as needed. The structured nature of the protocol ensures clarity in operations, making it suitable for formal verification and analysis using tools like Maude-NPA.\n\n### Generation of Maude File\nThis description can be used to develop a new Maude file that accurately reflects the protocol's requirements and operations. You can specify additional features or modifications based on testing and evaluation of the protocol's functionality.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 22:49:20 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"bank-command\", line 4: bad token run.\nWarning: \"bank-command\", line 4: no parse for term.\nWarning: \"bank-command\", line 5: bad token initials.\nWarning: \"bank-command\", line 5: no parse for term.",
                0.628551721572876
            ]
        ]
    },
    {
        "file": "MAUDE-1/bike.maude",
        "logic": "### Protocol Description: BIKE\n\n#### Overview\nBIKE is a key encapsulation mechanism based on polynomial arithmetic. It involves several participants, specifically Alice, Bob, and an intruder Eve, who may attempt to intercept messages. The protocol includes operations for key generation, encryption, and decryption, with a focus on maintaining the confidentiality and integrity of the key exchange process.\n\n#### Participants\n1. **Alice**: Initiates the key exchange, generates keys, and sends messages.\n2. **Bob**: Responds to Alice's messages and participates in the key exchange.\n3. **Eve**: An adversary who may try to intercept or modify messages between Alice and Bob.\n\n#### Data Types\n- **Polynomials**: Represent keys and messages. Operations include addition and multiplication of polynomials, which are used to compute shared keys and messages.\n- **Pairs**: Used to encapsulate data structures consisting of two elements, such as error values resulting from hash functions.\n- **Messages**: Structured data that includes sender, receiver, state, and content.\n\n#### Operations\n1. **Key Generation**:\n   - Each participant samples polynomials and computes a public key from a private key. \n   - The public key is sent to the other participant.\n\n2. **Encryption**:\n   - The sender (e.g., Alice) generates a shared key and a ciphertext based on the public key received from the other participant.\n   - The ciphertext is sent to the recipient (e.g., Bob).\n\n3. **Decryption**:\n   - The recipient uses the received ciphertext and their own keys to derive the shared key.\n   - The protocol assumes that the errors in the ciphertext can be perfectly reconstructed.\n\n#### Behavior Rules\n- **Honest Participant Behavior**:\n  - Participants follow the protocol by generating keys, sending public keys, and exchanging ciphertexts.\n  - Upon receiving a public key or ciphertext, the participant computes the shared key.\n\n- **Intruder Behavior**:\n  - The intruder can intercept public keys and ciphertexts, potentially altering them before forwarding.\n  - The intruder can also perform identity attacks by masquerading as a legitimate participant.\n\n#### Initial States\nThe protocol begins with a predefined state where participants have empty keys and peers. The initial states define the messages and polynomial values each participant holds before the exchange begins.\n\n#### Conclusion\nThe BIKE protocol is designed for secure key exchange using polynomial arithmetic, with provisions to account for potential adversarial actions. The structured operations and roles of participants are defined to facilitate a robust key encapsulation mechanism.\n\n### Maude File Generation\nBased on the above description, one could generate a Maude file that captures the defined operations, data types, and behaviors of the BIKE protocol. The key components, such as polynomial operations, key generation, message structure, participant behaviors, and rules for both honest and adversarial actions, would be expressed in a similar format to the provided Maude file.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 18:19:04 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"bike-command\", line 4: bad token run.\nWarning: \"bike-command\", line 4: no parse for term.\nWarning: \"bike-command\", line 5: bad token initials.\nWarning: \"bike-command\", line 5: no parse for term.",
                0.5760171413421631
            ]
        ]
    },
    {
        "file": "MAUDE-1/closeSocketFeb2020.maude",
        "logic": "### Protocol Description: Server Socket Shutdown\n\n#### Overview\nThis protocol models the lifecycle of a TCP server that manages connections through sockets. The focus is on the behavior of the server when it closes a socket that is currently accepting client connections. The protocol ensures that closing a socket does not lead to erroneous states or infinite loops in the system.\n\n#### Components\n- **Server**: Represents the TCP server instance.\n- **Socket**: Represents the TCP socket that accepts incoming connections.\n- **State**: The server can be in one of two states:\n  - `init`: Indicates that the server is not yet accepting connections.\n  - `accepting(SSkt)`: Indicates that the server is currently accepting connections on a socket identified by `SSkt`.\n  - `closing`: Indicates that the server is in the process of closing the socket.\n\n#### Operations\n1. **Creating a Server**: The server is created and initialized in the `init` state.\n   - When the server is created, it triggers the `createdSocket` event, which transitions the server from the `init` state to the `accepting(SSkt)` state, where `SSkt` is the identifier of the created socket.\n\n2. **Accepting Connections**: While in the `accepting(SSkt)` state, the server can accept incoming client connections.\n\n3. **Closing the Socket**:\n   - When the server decides to close the socket while in the `accepting(SSkt)` state, it triggers the `closeSocket` operation, transitioning the state to `closing`.\n   - Once the socket is closed, the server receives a `closedSocket` notification, transitioning the state to `none`, indicating that the server is no longer accepting connections.\n\n#### Initial Configuration\nThe initial configuration of the protocol is defined to create a TCP server socket on a specified port (1234) with a maximum of 5 pending connections allowed. The initial state of the server is set to `init`.\n\n### Generated Maude File\nBased on the description above, you can create a new Maude file that accurately represents the protocol. The structure of the Maude file should follow the conventions shown in the provided code, making sure to define operations, sorts, and rewrite rules as needed.\n\nHere is a template you can use for generating the Maude file:\n\n```maude\nset show timing off .\nset show advisories off .\n\nload socket\n\nmod SERVER-SOCKET-SHUTDOWN is\n    protecting SOCKET .\n    op Server : -> Cid [ctor] .\n    op server : -> Oid [ctor] .\n    op state:_ : ServerState -> Attribute [ctor] .\n\n    sort ServerState .\n    ops init closing : -> ServerState [ctor] .\n    op accepting : Oid -> ServerState [ctor] .\n\n    var SSkt : Oid .\n    var Reason : String .\n\n    rl [createdSocket] :\n        < server : Server | state: init >\n        => \n        < server : Server | state: accepting(SSkt) >\n        acceptClient(SSkt, server) .\n\n    rl [close] :\n        < server : Server | state: accepting(SSkt) >\n        => \n        < server : Server | state: closing >\n        closeSocket(SSkt, server) .\n\n    rl [closedSocket] :\n        < server : Server | state: closing >\n        => \n        none .\n\n    op initial : -> Configuration .\n    eq initial = <> < server : Server | state: init >\n                 createServerTcpSocket(socketManager, server, 1234, 5) .\nendm\n\nrew initial .\n```\n\n### Conclusion\nThis description and the structured template should facilitate the understanding of the server socket shutdown protocol and provide a basis for implementing the corresponding Maude file in the Maude-NPA environment. You can modify the details as needed to match any additional specifications or requirements.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 13:20:59 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nerewrite in SERVER-SHUTDOWN : initial .\nrewrites: 0\nresult Configuration: initial\nBye.Warning: \"closeSocketFeb2020.maude\", line 10: unable to locate file: socket\nWarning: \"closeSocketFeb2020.maude\", line 12 (mod SERVER-SHUTDOWN): module\n    SOCKET does not exist.\nWarning: \"closeSocketFeb2020.maude\", line 13 (mod SERVER-SHUTDOWN): undeclared\n    sort Cid.\nWarning: \"closeSocketFeb2020.maude\", line 14 (mod SERVER-SHUTDOWN): undeclared\n    sort Oid.\nWarning: \"closeSocketFeb2020.maude\", line 15 (mod SERVER-SHUTDOWN): undeclared\n    sort Attribute.\nWarning: \"closeSocketFeb2020.maude\", line 22 (mod SERVER-SHUTDOWN): undeclared\n    sort String.\nWarning: \"closeSocketFeb2020.maude\", line 42 (mod SERVER-SHUTDOWN): undeclared\n    sort Configuration.\nWarning: \"closeSocketFeb2020.maude\", line 24 (mod SERVER-SHUTDOWN): bad token\n    <.\nWarning: \"closeSocketFeb2020.maude\", line 23 (mod SERVER-SHUTDOWN): no parse\n    for statement\nrl [createdSocket] : < server : Server | state: init > createdSocket (server,\n    socketManager, SSkt) => < server : Server | state: accepting (SSkt) >\n    acceptClient (SSkt, server) .\nWarning: \"closeSocketFeb2020.maude\", line 31 (mod SERVER-SHUTDOWN): bad token\n    <.\nWarning: \"closeSocketFeb2020.maude\", line 30 (mod SERVER-SHUTDOWN): no parse\n    for statement\nrl [close] : < server : Server | state: accepting (SSkt) > => < server : Server\n    | state: closing > closeSocket (SSkt, server) .\nWarning: \"closeSocketFeb2020.maude\", line 37 (mod SERVER-SHUTDOWN): bad token\n    <.\nWarning: \"closeSocketFeb2020.maude\", line 36 (mod SERVER-SHUTDOWN): no parse\n    for statement\nrl [close] : < server : Server | state: closing > closedSocket (server, SSkt,\n    Reason) => none .\nWarning: \"closeSocketFeb2020.maude\", line 43 (mod SERVER-SHUTDOWN): bad token\n    <>.\nWarning: \"closeSocketFeb2020.maude\", line 43 (mod SERVER-SHUTDOWN): no parse\n    for statement\neq initial = <> < server : Server | state: init > createServerTcpSocket (\n    socketManager, server, 1234, 5) .\nWarning: \"closeSocketFeb2020-command\", line 4: bad token run.\nWarning: \"closeSocketFeb2020-command\", line 4: no parse for term.\nWarning: \"closeSocketFeb2020-command\", line 5: bad token initials.\nWarning: \"closeSocketFeb2020-command\", line 5: no parse for term.",
                0.6288158893585205
            ]
        ]
    },
    {
        "file": "MAUDE-1/complexParserSyncApril2020.maude",
        "logic": "### Protocol Description\n\n**Protocol Name: NAT Authentication Protocol**\n\n**Overview:**\nThe NAT Authentication Protocol is designed to facilitate secure communications in a network environment where Network Address Translation (NAT) is employed. This protocol ensures that messages exchanged between nodes are authentic and confidential, leveraging cryptographic techniques to protect against unauthorized access and denial of service attacks.\n\n**Components:**\n1. **Participants**:\n   - **Client**: Initiates communication and sends requests to the server.\n   - **Server**: Responds to client requests and manages authentication.\n\n2. **Messages**:\n   - **Authentication Request**: Sent by the client to the server to initiate the authentication process.\n   - **Authentication Response**: Sent by the server to the client, containing the result of the authentication attempt.\n\n3. **Key Management**:\n   - The protocol employs a key exchange mechanism to ensure that both parties share a secret key, which is used for encrypting messages.\n\n**Steps of the Protocol**:\n1. **Key Exchange**: \n   - The client generates a pair of keys (public and private) and shares the public key with the server.\n   - The server generates a random nonce and sends it back to the client encrypted with the client's public key.\n\n2. **Authentication**:\n   - The client uses the nonce and its private key to create an authentication token, which is then sent to the server.\n   - The server validates the token using the client's public key and responds with an authentication status (success or failure).\n\n**Security Goals**:\n- Ensure that only legitimate clients can authenticate with the server.\n- Protect against replay attacks by using nonces.\n- Provide confidentiality and integrity of messages exchanged between the client and server.\n\n**Maude-NPA Specifics**:\nThe Maude-NPA tool is utilized to model and analyze the security properties of the NAT Authentication Protocol. The protocol is defined within a Maude module that outlines the syntax for representing the participants, messages, and cryptographic operations.\n\n**Module Definition**:\nThe Maude module for the NAT Authentication Protocol can be defined as follows:\n```maude\nmod NAT is\n  ... % Definitions for messages, states, and operations\nendm\n```\n\n### Conclusion\nThe NAT Authentication Protocol ensures secure communication in a NAT environment by employing cryptography and secure message exchanges. The protocol is modeled using the Maude-NPA tool to facilitate formal analysis of its security properties.\n\n### Example Maude File\nBased on the protocol description, you can create a more detailed Maude file that includes definitions of the involved protocols, states, and operations, similar to the following structure:\n\n```maude\nmod NAT is\n  // Definitions for messages\n  op authReq : Nat -> Msg .\n  op authResp : Nat -> Msg .\n  \n  // Definitions for keys\n  op publicKey : Nat -> Key .\n  op privateKey : Nat -> Key .\n  \n  // States\n  op clientState : Nat -> State .\n  op serverState : Nat -> State .\n\n  // Protocol operations\n  op keyExchange : Nat Nat -> Msg .\n  op authenticate : Msg Msg -> Bool .\n\n  // Transition rules\n  ...\n  \nendm\n```",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 13:45:23 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"complexParserSyncApril2020.maude\", line 11: didn't expect token ,:\nmetaParse ( upModule ( 'NAT , false ) , none , '0 , <---*HERE*\nWarning: \"complexParserSyncApril2020.maude\", line 11: no parse for term.\nWarning: \"complexParserSyncApril2020.maude\", line 12: bad token\n    metaParseStrategy.\nWarning: \"complexParserSyncApril2020.maude\", line 12: no parse for term.\nWarning: \"complexParserSyncApril2020.maude\", line 13: didn't expect token ,:\nmetaParse ( upModule ( 'NAT , false ) , none , '0 , <---*HERE*\nWarning: \"complexParserSyncApril2020.maude\", line 13: no parse for term.\nWarning: \"complexParserSyncApril2020-command\", line 4: bad token run.\nWarning: \"complexParserSyncApril2020-command\", line 4: no parse for term.\nWarning: \"complexParserSyncApril2020-command\", line 5: bad token initials.\nWarning: \"complexParserSyncApril2020-command\", line 5: no parse for term.",
                0.578261137008667
            ]
        ]
    },
    {
        "file": "MAUDE-1/conditionSideEffectInStrategyLanguageDecember2023.maude",
        "logic": "---\n\n**Protocol Description: Non-executable Rule Testing in Maude-NPA**\n\n**Overview:**\nThe protocol defined in the Maude file is designed to illustrate a specific behavior in rewriting systems, particularly focusing on the interaction between executable and non-executable rules. The main goal of this protocol is to demonstrate the handling of conditions that influence the rewriting process, especially in the context of unrewritable and unstackable flags.\n\n**Module Definition:**\nThe protocol is encapsulated in a Maude module named `NONEXEC`, which includes two sorts, `Foo` and `Bar`, along with constructors for creating instances of `Foo` (`a` and `b`) and a constructor for wrapping `Foo` instances into `Bar` (`<_>`).\n\n**Operations:**\n1. **Constructors:**\n   - `a` and `b`: These are the basic elements of the sort `Foo` and serve as the initial terms for rewriting.\n   - `<_>`: A constructor that takes an element of `Foo` and produces an element of `Bar`.\n\n2. **Variables:**\n   - `F` and `G`: These are variables of sort `Foo` used within the rewriting rules.\n\n**Rewriting Rules:**\n1. **Conditional Rewrite Rule (CRL):**\n   - The rule `< F > => < G >` states that a term containing `F` can be rewritten to a term containing `G` if `F` can be rewritten to `G`, and `F` is not equal to `G`. This rule expresses a conditional transformation based on the relationship between `F` and `G`.\n\n2. **Non-executable Rule (RL):**\n   - The rule `[ab] : a => b [nonexec]` specifies that the term `a` can be rewritten to `b`, but this rule is marked as non-executable (`nonexec`). This means that this rule should not affect the rewriting process in certain contexts, particularly when certain flags (unrewritable/unstackable) are considered.\n\n**Execution:**\n- The command `srew < a > using try(all) ; ab` initiates a strategy for rewriting the term `< a >`. The `try(all)` command attempts to apply all applicable rules (both executable and non-executable) while respecting the conditions set by the flags.\n\n**Purpose:**\nThis protocol serves as a test case for a bug found by Paco, which relates to how condition evaluations set flags (unrewritable/unstackable) that influence the rewriting process. By observing how the system behaves with the specified rules, one can gain insights into the interplay between executable and non-executable rules in Maude-NPA.\n\n**Conclusion:**\nThe `NONEXEC` module exemplifies how Maude can be used to model and analyze rewriting systems with complex rule interactions, particularly focusing on non-executable rules and their handling during the rewriting process.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 17:50:32 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nsrewrite in NONEXEC : < a > using try(all) ; ab .\n\nNo more solutions.\nrewrites: 1\nBye.Warning: \"conditionSideEffectInStrategyLanguageDecember2023-command\", line 4:\n    bad token run.\nWarning: \"conditionSideEffectInStrategyLanguageDecember2023-command\", line 4:\n    no parse for term.\nWarning: \"conditionSideEffectInStrategyLanguageDecember2023-command\", line 5:\n    bad token initials.\nWarning: \"conditionSideEffectInStrategyLanguageDecember2023-command\", line 5:\n    no parse for term.",
                0.6277692317962646
            ]
        ]
    },
    {
        "file": "MAUDE-1/CUIbug12-22-09.maude",
        "logic": "Based on the provided Maude file, I will describe the protocol and its key components. This description will help you generate a corresponding Maude file that can be run by the Maude-NPA tool.\n\n### Protocol Description\n\n**Protocol Name:** CUI-BUG\n\n**Overview:**\nThis protocol is designed to demonstrate an issue with the rewriting mechanism of the Maude-NPA tool, specifically related to the handling of unstackable flags during the argument stacking process. The bug was discovered on December 22, 2009, and was resolved in a subsequent alpha release.\n\n**Components:**\n\n1. **Sorts and Operations:**\n   - The protocol defines a sort `Foo`, which represents the data type for the protocol's operations.\n   - Four constant operations are defined (`a`, `b`, `c`, `d`) and are all of type `Foo`.\n   - An operation `f` is defined that takes two arguments of type `Foo` and returns a value of type `Foo`. This operation has an identity of `1`, meaning it behaves as an identity function for certain rewriting contexts.\n   - Another operation `g` is defined, which takes a single argument of type `Foo` and returns a value of type `Foo`.\n\n2. **Rewrite Rules:**\n   - The protocol includes two rewrite rules:\n     - The first rule rewrites `b` to `c`.\n     - The second rule rewrites `c` to `d`.\n   - The rewrite rule for `g(c)` to `d` is crucial for the second version of the protocol (CUI-BUG2), as it illustrates how the incorrect handling of unstackable flags leads to missed rewrites.\n\n3. **Rewrite Commands:**\n   - The command `rew f(a, g(b))` initiates the rewriting process for the expression `f(a, g(b))`.\n\n**Bug Analysis:**\n- During the first pass of rewriting, the operation `f` was marked as unrewritable due to the incorrect handling of the unstackable flag for its arguments (`a` and `g(b)`).\n- The rewriting process attempted to stack `a` and `g(b)`, but neither could be rewritten.\n- The rewriting engine did not recognize that `g(b)` could rewrite to `g(c)` and subsequently to `d`, leading to a missed opportunity to rewrite `f(a, g(b))` to `f(a, d)`.\n\n**Resolution:**\n- In the modified protocol (CUI-BUG2), the rewrite rule is adjusted to allow `g(c)` to rewrite to `d`, addressing the previously identified bug and ensuring that the rewrite process can now proceed correctly.\n\n### Corresponding Maude File for CUI-BUG2\n\nBelow is the Maude file that implements the corrected protocol (CUI-BUG2):\n\n```maude\nmod CUI-BUG2 is\n  sort Foo .\n  ops a b c d 1 : -> Foo .\n  op f : Foo Foo -> Foo  [id: 1] .\n  op g : Foo -> Foo .\n\n  rl b => c .\n  rl g(c) => d .\nendm\n\nrew f(a, g(b)) .\n```\n\n### Conclusion\nThis description and the corresponding Maude file for the corrected protocol provide a structured overview of the original issue and its resolution. You can use this information to generate or modify Maude files as necessary for testing and verification in the Maude-NPA environment.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 22:48:49 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nrewrite in CUI-BUG : f(a, g(b)) .\nrewrites: 2\nresult Foo: f(a, g(d))\n==========================================\nrewrite in CUI-BUG2 : f(a, g(b)) .\nrewrites: 2\nresult Foo: f(a, d)\nBye.Warning: \"CUIbug12-22-09-command\", line 4: bad token run.\nWarning: \"CUIbug12-22-09-command\", line 4: no parse for term.\nWarning: \"CUIbug12-22-09-command\", line 5: bad token initials.\nWarning: \"CUIbug12-22-09-command\", line 5: no parse for term.",
                0.6291155815124512
            ]
        ]
    },
    {
        "file": "MAUDE-1/CUI_OccursCheckSeptember2020.maude",
        "logic": "### Protocol Description\n\n#### Title: Non-Termination Testing in Unification\n\n#### Overview\nThis protocol consists of two separate modules designed to test for non-termination in unification processes due to the absence of indirect occurs checks. The first module (`U-TEST`) focuses on unification in a non-commutative context, while the second module (`CU-TEST`) examines unification with commutative operations.\n\n#### Module: U-TEST\n- **Sorts and Operations**:\n  - A sort named `Foo` is defined.\n  - A constant `1` and an operation `a` are declared, where `a` has no arguments and returns an element of type `Foo`.\n  - An operation `f` is defined, which takes two arguments of type `Foo` and returns a `Foo`. It is designated as an identity operation with respect to the constant `1`.\n\n- **Variables**:\n  - The variables `A`, `B`, `C`, `X`, `Y`, and `Z` are all of type `Foo`.\n\n- **Unification Tests**:\n  - Several unification constraints are defined to test for non-termination. These include relationships between variables and the operation `f`, examining various configurations that may lead to infinite reduction sequences.\n\n#### Module: CU-TEST\n- **Sorts and Operations**:\n  - Similar to `U-TEST`, this module also defines the sort `Foo`.\n  - A constant `1` and an operation `a` are defined, with the same properties as in `U-TEST`.\n  - The operation `f` is defined as commutative, meaning that `f(X, Y) = f(Y, X)` holds true.\n\n- **Variables**:\n  - The same set of variables (`A`, `B`, `C`, `X`, `Y`, `Z`) is utilized.\n\n- **Unification Tests**:\n  - The module includes several unification constraints that test for non-termination in a commutative context, similarly examining configurations that could lead to infinite reductions.\n\n### Summary\nThe protocol implemented in these two modules serves as a test case for analyzing the behavior of unification processes in the presence of potential non-termination conditions. By examining both commutative and non-commutative scenarios, this protocol provides insight into how indirect occurs checks affect unification in Maude.\n\n### Corresponding Maude File Generation\nTo generate the Maude file, the following structure should be followed, ensuring that it adheres to the specifications outlined in the protocol description:\n\n```maude\nset show timing off .\nset show advisories off .\n\nfmod U-TEST is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op f : Foo Foo -> Foo [id: 1] .\n  vars A B C X Y Z : Foo .\nendfm\n\nirred unify X =? f(Z, Y) /\\ Z =? f(X, Y) /\\ f(X, Y) =? f(A, B) .\nirred unify f(X, Y) =? a /\\ Z =? f(X, Y) /\\ X =? f(Z, Y) .\nirred unify X =? f(f(f(X, Y), X), Y) .\nirred unify X =? f(f(f(X, X), Z), Y) .\nirred unify X =? f(f(X, Y), f(Y, X)) .\nirred unify X =? f(f(f(f(Y, X), Y), X), Z) .\n\nfmod CU-TEST is\n  sort Foo .\n  ops 1 a : -> Foo .\n  op f : Foo Foo -> Foo [comm id: 1] .\n  vars A B C X Y Z : Foo .\nendfm\n\nirred unify X =? f(Z, Y) /\\ Z =? f(X, Y) /\\ f(X, Y) =? f(A, B) .\nirred unify f(X, Y) =? a /\\ Z =? f(X, Y) /\\ X =? f(Z, Y) .\nirred unify X =? f(f(f(X, Y), X), Y) .\nirred unify X =? f(f(f(X, X), Z), Y) .\nirred unify X =? f(f(f(f(Y, X), Y), X), Z) .\n```",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.6 built: Dec  9 2010 18:28:39\n\t    Copyright 1997-2010 SRI International\n\t\t   Wed May 21 13:22:05 2025\n\n\t    Maude-NPA Version: 11/26/2011\n\t    Copyright (c) 2012, University of Illinois\n\t    All rights reserved.\n\n==========================================\nunify in U-TEST : X =? f(Z, Y) /\\ Z =? f(X, Y) /\\ f(X, Y) =? f(A, B) .\n==========================================\nunify in U-TEST : f(X, Y) =? a /\\ Z =? f(X, Y) /\\ X =? f(Z, Y) .\n==========================================\nunify in U-TEST : X =? f(f(f(X, Y), X), Y) .\n==========================================\nunify in U-TEST : X =? f(f(f(X, X), Z), Y) .\n==========================================\nunify in U-TEST : X =? f(f(X, Y), f(Y, X)) .\n==========================================\nunify in U-TEST : X =? f(f(f(f(Y, X), Y), X), Z) .\n==========================================\nunify in CU-TEST : X =? f(Z, Y) /\\ Z =? f(X, Y) /\\ f(X, Y) =? f(A, B) .\n==========================================\nunify in CU-TEST : f(X, Y) =? a /\\ Z =? f(X, Y) /\\ X =? f(Z, Y) .\n==========================================\nunify in CU-TEST : X =? f(f(f(X, Y), X), Y) .\n==========================================\nunify in CU-TEST : X =? f(f(f(X, X), Z), Y) .\n==========================================\nunify in CU-TEST : X =? f(f(f(f(Y, X), Y), X), Z) .\nBye.",
                0.679079532623291
            ]
        ]
    },
    {
        "file": "MAUDE-1/CU_Unification.maude",
        "logic": "### Description of the Protocol\n\n1. **Module FOO (Ul Theory)**:\n   - **Structure**: This module defines a binary operation `f` on the sort `Foo` with a left identity element `1f`.\n   - **Properties**: \n     - The operation `f` is left associative, meaning that `f(a, f(b, c))` is equivalent to `f(f(a, b), c)`.\n     - The identity element `1f` satisfies the property `f(1f, X) = X` for any `X` in `Foo`.\n   - **Unification**: It allows unification of terms involving `f`, including cases where one term is a variable and the other is an application of `f`.\n\n2. **Module FOO2 (Ur Theory)**:\n   - **Structure**: This module defines the same binary operation `f` with a right identity element `1f`.\n   - **Properties**: \n     - The operation `f` is right associative, meaning that `f(f(a, b), c)` is equivalent to `f(a, f(b, c))`.\n     - The identity element `1f` satisfies the property `f(X, 1f) = X` for any `X` in `Foo`.\n   - **Unification**: Similar to the first module, it allows unification of terms with respect to the right identity.\n\n3. **Module FOO3 (U Theory)**:\n   - **Structure**: This module defines the operation `f` with a neutral identity element `1f`.\n   - **Properties**: \n     - The operation is neither left nor right associative but simply has an identity element, meaning `f(1f, X) = X` and `f(X, 1f) = X` hold.\n   - **Unification**: Allows for unification similar to the previous modules.\n\n4. **Module FOO4 (CU Theory)**:\n   - **Structure**: This module defines the operation `f` with a commutative identity element.\n   - **Properties**: \n     - The operation `f` is commutative, meaning `f(X, Y) = f(Y, X)` holds for any `X, Y` in `Foo`.\n     - It also has an identity element `1f` such that `f(X, 1f) = X` and `f(1f, X) = X`.\n   - **Unification**: Unification rules similar to prior modules, but with the added property of commutativity.\n\n### Generating the Corresponding Maude File\n\nTo generate a Maude file that corresponds to the description content provided, one would structure it similarly to the original code but explicitly document the protocol's purpose, properties, and operations. Here's an example of how the Maude file might be structured based on the description:\n\n```maude\nset show timing off .\n\n*** Unified Protocol Theory\n\nfmod PROTOCOL is\n  sort Foo .\n  op f : Foo Foo -> Foo [comm id: 1f] .\n  op 1f : -> Foo .\n\n  vars U V W X Y Z : Foo .\n\n  *** Properties\n  *** Left Identity\n  eq f(1f, X) = X .\n  \n  *** Right Identity\n  eq f(X, 1f) = X .\n\n  *** Commutativity\n  eq f(X, Y) = f(Y, X) .\n\n  *** Associativity\n  eq f(f(X, Y), Z) = f(X, f(Y, Z)) .\n  eq f(X, f(Y, Z)) = f(f(X, Y), Z) .\n\nendfm\n\n*** Unification\nunify f(X, Y) =? f(U, V) .\nvariant unify f(X, Y) =? f(U, V) .\n\nunify f(X, Y) =? X .\nvariant unify f(X, Y) =? X .\n\nunify f(X, Y) =? Y .\nvariant unify f(X, Y) =? Y .\n```\n\n### Note\nThe above Maude file captures the essence of your original modules while unifying their properties into a single protocol. Each operation and property is aligned with the descriptions given to ensure clarity and maintain the original intent of the specifications.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Thu May 22 11:05:07 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nunify in FOO : f(X, Y) =? f(U, V) .\n\nSolution 1\nX --> #1:Foo\nY --> #2:Foo\nU --> #1:Foo\nV --> #2:Foo\n\nSolution 2\nX --> 1f\nY --> #1:Foo\nU --> 1f\nV --> #1:Foo\n\nSolution 3\nX --> 1f\nY --> f(#1:Foo, #2:Foo)\nU --> #1:Foo\nV --> #2:Foo\n\nSolution 4\nX --> 1f\nY --> #1:Foo\nU --> 1f\nV --> #1:Foo\n\nSolution 5\nX --> #1:Foo\nY --> #2:Foo\nU --> 1f\nV --> f(#1:Foo, #2:Foo)\n==========================================\nvariant unify in FOO : f(X, Y) =? f(U, V)  .\n\nUnifier #1\nrewrites: 0\nX --> %1:Foo\nY --> %2:Foo\nU --> %1:Foo\nV --> %2:Foo\n\nUnifier #2\nrewrites: 0\nX --> 1f\nY --> f(%1:Foo, %2:Foo)\nU --> %1:Foo\nV --> %2:Foo\n\nUnifier #3\nrewrites: 0\nX --> %1:Foo\nY --> %2:Foo\nU --> 1f\nV --> f(%1:Foo, %2:Foo)\n\nNo more unifiers.\nrewrites: 0\n==========================================\nunify in FOO : f(X, Y) =? X .\n\nSolution 1\nX --> 1f\nY --> 1f\n==========================================\nvariant unify in FOO : f(X, Y) =? X  .\n\nUnifier #1\nrewrites: 0\nX --> 1f\nY --> 1f\n\nNo more unifiers.\nrewrites: 0\n==========================================\nunify in FOO : f(X, Y) =? Y .\n\nSolution 1\nX --> 1f\nY --> #1:Foo\n==========================================\nvariant unify in FOO : f(X, Y) =? Y  .\n\nUnifier #1\nrewrites: 0\nX --> 1f\nY --> %1:Foo\n\nNo more unifiers.\nrewrites: 0\n==========================================\nunify in FOO2 : f(X, Y) =? f(U, V) .\n\nSolution 1\nX --> #1:Foo\nY --> #2:Foo\nU --> #1:Foo\nV --> #2:Foo\n\nSolution 2\nX --> #1:Foo\nY --> 1f\nU --> #1:Foo\nV --> 1f\n\nSolution 3\nX --> f(#1:Foo, #2:Foo)\nY --> 1f\nU --> #1:Foo\nV --> #2:Foo\n\nSolution 4\nX --> #1:Foo\nY --> 1f\nU --> #1:Foo\nV --> 1f\n\nSolution 5\nX --> #1:Foo\nY --> #2:Foo\nU --> f(#1:Foo, #2:Foo)\nV --> 1f\n==========================================\nvariant unify in FOO2 : f(X, Y) =? f(U, V)  .\n\nUnifier #1\nrewrites: 0\nX --> %1:Foo\nY --> %2:Foo\nU --> %1:Foo\nV --> %2:Foo\n\nUnifier #2\nrewrites: 0\nX --> f(%1:Foo, %2:Foo)\nY --> 1f\nU --> %1:Foo\nV --> %2:Foo\n\nUnifier #3\nrewrites: 0\nX --> %1:Foo\nY --> %2:Foo\nU --> f(%1:Foo, %2:Foo)\nV --> 1f\n\nNo more unifiers.\nrewrites: 0\n==========================================\nunify in FOO2 : f(X, Y) =? X .\n\nSolution 1\nX --> #1:Foo\nY --> 1f\n==========================================\nvariant unify in FOO2 : f(X, Y) =? X  .\n\nUnifier #1\nrewrites: 0\nX --> %1:Foo\nY --> 1f\n\nNo more unifiers.\nrewrites: 0\n==========================================\nunify in FOO2 : f(X, Y) =? Y .\n\nSolution 1\nX --> 1f\nY --> 1f\n==========================================\nvariant unify in FOO2 : f(X, Y) =? Y  .\n\nUnifier #1\nrewrites: 0\nX --> 1f\nY --> 1f\n\nNo more unifiers.\nrewrites: 0\n==========================================\nunify in FOO3 : f(X, Y) =? f(U, V) .\n\nSolution 1\nX --> #1:Foo\nY --> #2:Foo\nU --> #1:Foo\nV --> #2:Foo\n\nSolution 2\nX --> 1f\nY --> #1:Foo\nU --> 1f\nV --> #1:Foo\n\nSolution 3\nX --> 1f\nY --> #1:Foo\nU --> #1:Foo\nV --> 1f\n\nSolution 4\nX --> 1f\nY --> f(#1:Foo, #2:Foo)\nU --> #1:Foo\nV --> #2:Foo\n\nSolution 5\nX --> #1:Foo\nY --> 1f\nU --> 1f\nV --> #1:Foo\n\nSolution 6\nX --> #1:Foo\nY --> 1f\nU --> #1:Foo\nV --> 1f\n\nSolution 7\nX --> f(#1:Foo, #2:Foo)\nY --> 1f\nU --> #1:Foo\nV --> #2:Foo\n\nSolution 8\nX --> 1f\nY --> #1:Foo\nU --> 1f\nV --> #1:Foo\n\nSolution 9\nX --> #1:Foo\nY --> 1f\nU --> 1f\nV --> #1:Foo\n\nSolution 10\nX --> #1:Foo\nY --> #2:Foo\nU --> 1f\nV --> f(#1:Foo, #2:Foo)\n\nSolution 11\nX --> 1f\nY --> #1:Foo\nU --> #1:Foo\nV --> 1f\n\nSolution 12\nX --> #1:Foo\nY --> 1f\nU --> #1:Foo\nV --> 1f\n\nSolution 13\nX --> #1:Foo\nY --> #2:Foo\nU --> f(#1:Foo, #2:Foo)\nV --> 1f\n==========================================\nvariant unify in FOO3 : f(X, Y) =? f(U, V)  .\n\nUnifier #1\nrewrites: 0\nX --> %1:Foo\nY --> %2:Foo\nU --> %1:Foo\nV --> %2:Foo\n\nUnifier #2\nrewrites: 0\nX --> 1f\nY --> f(%1:Foo, %2:Foo)\nU --> %1:Foo\nV --> %2:Foo\n\nUnifier #3\nrewrites: 0\nX --> f(%1:Foo, %2:Foo)\nY --> 1f\nU --> %1:Foo\nV --> %2:Foo\n\nUnifier #4\nrewrites: 0\nX --> %1:Foo\nY --> %2:Foo\nU --> 1f\nV --> f(%1:Foo, %2:Foo)\n\nUnifier #5\nrewrites: 0\nX --> %1:Foo\nY --> %2:Foo\nU --> f(%1:Foo, %2:Foo)\nV --> 1f\n\nNo more unifiers.\nrewrites: 0\n==========================================\nunify in FOO3 : f(X, Y) =? X .\n\nSolution 1\nX --> 1f\nY --> 1f\n\nSolution 2\nX --> #1:Foo\nY --> 1f\n==========================================\nvariant unify in FOO3 : f(X, Y) =? X  .\n\nUnifier #1\nrewrites: 0\nX --> %1:Foo\nY --> 1f\n\nNo more unifiers.\nrewrites: 0\n==========================================\nunify in FOO3 : f(X, Y) =? Y .\n\nSolution 1\nX --> 1f\nY --> #1:Foo\n\nSolution 2\nX --> 1f\nY --> 1f\n==========================================\nvariant unify in FOO3 : f(X, Y) =? Y  .\n\nUnifier #1\nrewrites: 0\nX --> 1f\nY --> %1:Foo\n\nNo more unifiers.\nrewrites: 0\n==========================================\nunify in FOO4 : f(X, Y) =? f(U, V) .\n\nSolution 1\nX --> #1:Foo\nY --> #2:Foo\nV --> #1:Foo\nU --> #2:Foo\n\nSolution 2\nX --> #2:Foo\nY --> #1:Foo\nV --> #1:Foo\nU --> #2:Foo\n\nSolution 3\nX --> 1f\nY --> #1:Foo\nV --> 1f\nU --> #1:Foo\n\nSolution 4\nX --> 1f\nY --> #1:Foo\nV --> #1:Foo\nU --> 1f\n\nSolution 5\nX --> 1f\nY --> f(#1:Foo, #2:Foo)\nV --> #1:Foo\nU --> #2:Foo\n\nSolution 6\nX --> #1:Foo\nY --> 1f\nV --> 1f\nU --> #1:Foo\n\nSolution 7\nX --> #1:Foo\nY --> 1f\nV --> #1:Foo\nU --> 1f\n\nSolution 8\nX --> f(#1:Foo, #2:Foo)\nY --> 1f\nV --> #1:Foo\nU --> #2:Foo\n\nSolution 9\nX --> 1f\nY --> #1:Foo\nV --> 1f\nU --> #1:Foo\n\nSolution 10\nX --> #1:Foo\nY --> 1f\nV --> 1f\nU --> #1:Foo\n\nSolution 11\nX --> #1:Foo\nY --> #2:Foo\nV --> 1f\nU --> f(#1:Foo, #2:Foo)\n\nSolution 12\nX --> 1f\nY --> #1:Foo\nV --> #1:Foo\nU --> 1f\n\nSolution 13\nX --> #1:Foo\nY --> 1f\nV --> #1:Foo\nU --> 1f\n\nSolution 14\nX --> #1:Foo\nY --> #2:Foo\nV --> f(#1:Foo, #2:Foo)\nU --> 1f\n==========================================\nvariant unify in FOO4 : f(X, Y) =? f(U, V)  .\n\nUnifier #1\nrewrites: 0\nX --> %1:Foo\nY --> %2:Foo\nV --> %1:Foo\nU --> %2:Foo\n\nUnifier #2\nrewrites: 0\nX --> %2:Foo\nY --> %1:Foo\nV --> %1:Foo\nU --> %2:Foo\n\nUnifier #3\nrewrites: 0\nX --> 1f\nY --> f(%1:Foo, %2:Foo)\nV --> %1:Foo\nU --> %2:Foo\n\nUnifier #4\nrewrites: 0\nX --> f(%1:Foo, %2:Foo)\nY --> 1f\nV --> %1:Foo\nU --> %2:Foo\n\nUnifier #5\nrewrites: 0\nX --> %1:Foo\nY --> %2:Foo\nV --> 1f\nU --> f(%1:Foo, %2:Foo)\n\nUnifier #6\nrewrites: 0\nX --> %1:Foo\nY --> %2:Foo\nV --> f(%1:Foo, %2:Foo)\nU --> 1f\n\nNo more unifiers.\nrewrites: 0\n==========================================\nunify in FOO4 : f(X, Y) =? X .\n\nSolution 1\nX --> 1f\nY --> 1f\n\nSolution 2\nX --> #1:Foo\nY --> 1f\n==========================================\nvariant unify in FOO4 : f(X, Y) =? X  .\n\nUnifier #1\nrewrites: 0\nX --> %1:Foo\nY --> 1f\n\nNo more unifiers.\nrewrites: 0\n==========================================\nunify in FOO4 : f(X, Y) =? Y .\n\nSolution 1\nX --> 1f\nY --> #1:Foo\n\nSolution 2\nX --> 1f\nY --> 1f\n==========================================\nvariant unify in FOO4 : f(X, Y) =? Y  .\n\nUnifier #1\nrewrites: 0\nX --> 1f\nY --> %1:Foo\n\nNo more unifiers.\nrewrites: 0\nBye.Warning: \"CU_Unification-command\", line 4: bad token run.\nWarning: \"CU_Unification-command\", line 4: no parse for term.\nWarning: \"CU_Unification-command\", line 5: bad token initials.\nWarning: \"CU_Unification-command\", line 5: no parse for term.",
                0.5759119987487793
            ]
        ]
    },
    {
        "file": "MAUDE-1/degenerateFilteredVariantUnifyDecember2022.maude",
        "logic": "Based on the provided Maude file content, it seems that you are focusing on a test related to unifier filtering in the context of the Maude-NPA (Nondeterministic Protocol Analyzer) tool. Below is a description content of the protocol that reflects the purpose and structure of the Maude file:\n\n---\n\n### Protocol Description for Maude-NPA\n\n**Protocol Name:** Unifier Filtering Test Protocol\n\n**Purpose:**  \nThis protocol is designed to test a specific bug in the tuple creation mechanism of the Maude-NPA tool, particularly when it comes to unifier filtering where the unifiers involved are degenerate. The aim is to ensure that the unification process behaves correctly under these conditions.\n\n**Background:**  \nIn the context of term rewriting and unification in Maude, unifiers are mappings that make different terms identical. Degenerate unifiers refer to cases where the unifiers do not introduce new information or distinction, potentially leading to issues during the filtering process of unifiers.\n\n**Test Case:**  \nThe test case included in the protocol checks the equality of natural numbers. Specifically, it verifies that the unification of the natural number `1` with itself is successful and that the filtering mechanism correctly handles this case.\n\n**Commands Used:**\n1. `set show timing off.` \u2013 This command disables the display of timing information during the execution of Maude commands.\n2. `set show advisories off.` \u2013 This command disables advisory messages, allowing for cleaner output during the testing process.\n3. `filtered variant unify in NAT : 1 =? 1.` \u2013 This command attempts to unify the expression `1 = 1` within the natural numbers (NAT) and observes whether the filtering mechanism correctly processes this unification.\n\n**Expected Outcome:**  \nThe expected outcome of this test is that the unification should succeed without errors, indicating that the filtering mechanism is functioning as intended even with degenerate unifiers.\n\n---\n\n### Corresponding Maude File\n\nBased on the above description, the following Maude file can be inferred to be run by Maude-NPA:\n\n```maude\nset show timing off .\nset show advisories off .\n\n*** Test for bug in tuple creation for unifier filtering if the unifiers are degenerate. ***\nfiltered variant unify in NAT : 1 =? 1 .\n```\n\nYou can use this description to guide the creation of your Maude file or for documentation purposes related to this specific protocol test. If there are additional functionalities or components in your protocol, let me know, and I can expand the description accordingly.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 17:50:46 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nvariant unify in NAT : 1 =? 1  .\n\nUnifier #1\nrewrites: 0\n\nNo more unifiers.\nrewrites: 0\nBye.Warning: \"degenerateFilteredVariantUnifyDecember2022.maude\", line 9: skipped\n    unexpected token: filtered\nWarning: \"degenerateFilteredVariantUnifyDecember2022-command\", line 4: bad\n    token run.\nWarning: \"degenerateFilteredVariantUnifyDecember2022-command\", line 4: no parse\n    for term.\nWarning: \"degenerateFilteredVariantUnifyDecember2022-command\", line 5: bad\n    token initials.\nWarning: \"degenerateFilteredVariantUnifyDecember2022-command\", line 5: no parse\n    for term.",
                0.6298739910125732
            ]
        ]
    },
    {
        "file": "MAUDE-1/dekker.maude",
        "logic": "---\n\n## Description of Dekker's Algorithm Protocol\n\n### Overview\nDekker's algorithm is a classic solution for mutual exclusion in concurrent programming. It ensures that two processes can safely share a single critical section without interfering with each other. This protocol employs shared memory and synchronization variables to manage access to the critical section.\n\n### Memory Model\nThe protocol defines a simple memory model with named locations (Qids) that hold integer values. The memory operations include basic arithmetic and equality tests, facilitating process coordination based on shared variables.\n\n### Programming Language Syntax\nA minimal sequential programming language is defined to express the logic of Dekker's algorithm. The syntax includes:\n- **Statements**: `skip`, assignment (`:=`), conditional statements (`if_then_fi`), loops (`while_do_od`), and repeat loops (`repeat_forever`).\n- **Programs**: A sequence of user statements can be represented using semicolons (`;`).\n\n### Process and Machine State\nThe protocol consists of processes identified by unique identifiers (Pids) which execute a given program. The machine state encapsulates the current processes, shared memory, and the last executing process identifier to facilitate fairness in execution.\n\n### Dekker\u2019s Algorithm Components\n1. **Processes**: Two processes (`p1` and `p2`) represent concurrent entities that require mutual exclusion when entering the critical section. Each process utilizes three shared variables: `c1`, `c2`, and `turn`.\n   - Both processes repeatedly check and modify these variables to control access to the critical section.\n   - The critical section (`crit`) and the remainder section (`rem`) are defined for each process, indicating the operations that can be performed when a process is in the critical or non-critical state.\n\n2. **Initial Conditions**: The initial memory setup assigns the values for `c1`, `c2`, and `turn`, initializing the system for the execution of `p1` and `p2`.\n\n### Model Checking\nThe protocol incorporates a model-checking framework to verify essential properties:\n- **Safety Property**: Ensures that both processes cannot be in their critical sections simultaneously, expressed as `[] ~ (enterCrit(1) /\\ enterCrit(2))`.\n- **Liveness Properties**: \n  - Strong Liveness: If process `p1` executes infinitely, it must eventually enter its critical section (not guaranteed in Dekker's algorithm).\n  - Weaker Liveness: If both processes execute infinitely, they must both eventually enter their critical sections.\n\n### Conclusion\nDekker's algorithm illustrates a foundational approach to mutual exclusion with an emphasis on process coordination through shared variables and control flow constructs. The provided Maude-NPA model captures its operational semantics and enables formal reasoning about its properties through model checking.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 13:21:46 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"dekker.maude\", line 13: unable to locate file: model-checker\nWarning: \"dekker.maude\", line 171 (mod CHECK): module MODEL-CHECKER does not\n    exist.\nWarning: \"dekker.maude\", line 172 (mod CHECK): undeclared sort State.\nWarning: \"dekker.maude\", line 173 (mod CHECK): undeclared sort Prop.\nWarning: \"dekker.maude\", line 180 (mod CHECK): bad token |=.\nWarning: \"dekker.maude\", line 180 (mod CHECK): no parse for statement\neq {[I, crit ; R] | S, M, J} |= enterCrit (I) = true .\nWarning: \"dekker.maude\", line 181 (mod CHECK): bad token |=.\nWarning: \"dekker.maude\", line 181 (mod CHECK): no parse for statement\neq {S, M, J} |= exec (J) = true .\nWarning: \"dekker.maude\", line 190: bad token modelCheck.\nWarning: \"dekker.maude\", line 190: no parse for term.\nWarning: \"dekker.maude\", line 198: bad token modelCheck.\nWarning: \"dekker.maude\", line 198: no parse for term.\nWarning: \"dekker.maude\", line 206: bad token modelCheck.\nWarning: \"dekker.maude\", line 206: no parse for term.\nWarning: \"dekker-command\", line 4: bad token run.\nWarning: \"dekker-command\", line 4: no parse for term.\nWarning: \"dekker-command\", line 5: bad token initials.\nWarning: \"dekker-command\", line 5: no parse for term.",
                0.6280150413513184
            ]
        ]
    },
    {
        "file": "MAUDE-1/deleteTimerMarch2021.maude",
        "logic": "Based on the provided Maude file, the protocol can be described as follows:\n\n### Protocol Description\n\n#### Overview\nThis protocol is a test case designed to validate a specific behavior of a timer management system within a concurrency model. The focus is on ensuring that the `deleteTimer` operation does not leave the system in an inconsistent state after a timer is created and subsequently deleted.\n\n#### Components\n- **Classes and Identifiers**:\n  - `myClass`: Represents a class involved in the timer management system.\n  - `Cid`: A class identifier used to distinguish different classes.\n  - `Oid`: An object identifier used to refer to instances of objects within the system.\n  \n- **Operations**:\n  - `createTimer`: An operation that initiates a new timer associated with a specific object (in this case, `me`).\n  - `deleteTimer`: An operation that terminates an existing timer, identified by a specific object ID.\n\n#### Variables\n- `O`, `O2`, `O3`: These are object identifiers (Oid) used as placeholders for different instances within the protocol.\n\n#### Rules\n- The protocol contains a rewrite rule that specifies the following:\n  - When an object `O` of type `myClass` exists with no additional state (indicated by `none`), and a timer is created (`createdTimer(O, O2, O3)`), the state allows for the deletion of the timer (`deleteTimer(O3, me)`). This reflects the operation of deleting a timer that was previously created.\n\n#### Initial State\n- The initial state of the protocol is represented by the command:\n  ```maude\n  < me : myClass | none > createTimer(timeManager, me)\n  ```\n  This indicates that the object `me` of type `myClass` is in a state where it has just created a timer managed by `timeManager`.\n\n#### Objective\nThe primary goal of this protocol is to test and confirm that the `deleteTimer` operation can be executed without causing any inconsistencies in the system state, especially after the creation of a timer. The protocol aims to ensure that the Maude-NPA tool can handle these operations correctly without leading to any runtime errors or crashes.\n\n### Conclusion\nThis test case is crucial for verifying the robustness of the timer management system within the protocol, particularly in concurrent execution scenarios. By simulating the creation and deletion of timers, it serves as a foundation for further development and testing of more complex behaviors in the timer management system.\n\n---\n\nThis description can be used to generate the corresponding Maude file for the Maude-NPA tool. It outlines the components, operations, and rules clearly, facilitating the understanding and implementation of the protocol.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 13:24:10 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"deleteTimerMarch2021.maude\", line 11: unable to locate file: time\nWarning: \"deleteTimerMarch2021.maude\", line 13 (mod TEST): module TIME does not\n    exist.\nWarning: \"deleteTimerMarch2021.maude\", line 14 (mod TEST): undeclared sort Cid.\nWarning: \"deleteTimerMarch2021.maude\", line 15 (mod TEST): undeclared sort Oid.\nWarning: \"deleteTimerMarch2021.maude\", line 18 (mod TEST): bad token <.\nWarning: \"deleteTimerMarch2021.maude\", line 18 (mod TEST): no parse for\n    statement\nrl < O : myClass | none > createdTimer (O, O2, O3) => < O : myClass | none >\n    deleteTimer (O3, me) .\nWarning: \"deleteTimerMarch2021.maude\", line 22: bad token <>.\nWarning: \"deleteTimerMarch2021.maude\", line 22: no parse for term.\nWarning: \"deleteTimerMarch2021.maude\", line 23: didn't expect token 0:\n0 <---*HERE*\nWarning: \"deleteTimerMarch2021.maude\", line 23: no parse for term.\nWarning: \"deleteTimerMarch2021-command\", line 4: bad token run.\nWarning: \"deleteTimerMarch2021-command\", line 4: no parse for term.\nWarning: \"deleteTimerMarch2021-command\", line 5: bad token initials.\nWarning: \"deleteTimerMarch2021-command\", line 5: no parse for term.",
                0.6279315948486328
            ]
        ]
    },
    {
        "file": "MAUDE-1/dining-philosophers5.maude",
        "logic": "---\n\n### Description of the Dining Philosophers Protocol\n\nThe Dining Philosophers problem involves a fixed number of philosophers who alternate between thinking and eating. They share a limited number of chopsticks (resources), and each philosopher needs two chopsticks to eat. The challenge is to ensure that no philosopher starves while preventing deadlock situations.\n\n#### Components\n\n1. **Philosopher**: Each philosopher has a status that can be either thinking, hungry, or eating. The chopsticks are represented as a number indicating how many chopsticks a philosopher currently holds.\n\n2. **Chopstick**: Each chopstick is a shared resource that a philosopher needs to eat. A chopstick can only be held by one philosopher at a time.\n\n3. **Status**: The status of a philosopher can be:\n   - `thinking`: The philosopher is not attempting to eat.\n   - `hungry`: The philosopher wants to eat and is trying to acquire chopsticks.\n   - `eating`: The philosopher is currently eating.\n\n4. **Time**: Time is represented in discrete units. Each action (thinking, eating) takes a specified amount of time, which can be used to control the flow of the protocol.\n\n5. **State Configuration**: The state of the system is represented as a collection of philosophers and chopsticks, along with the current time.\n\n#### Operations\n\n- **get-hungry**: A philosopher changes their status from thinking to hungry.\n- **grab-stick**: A hungry philosopher attempts to pick up a chopstick. The operation checks if the philosopher can grab the chopstick based on their position relative to the chopstick.\n- **eat**: A hungry philosopher can eat if they have both chopsticks.\n- **stop-eating**: After eating, a philosopher returns to thinking, releases the chopsticks, and resets their timer.\n\n#### Time Management\n\nThe protocol tracks the time each philosopher spends in different states. Time is managed in such a way that philosophers can only eat for a limited duration. The `mte` (minimum time event) function calculates the minimum time remaining in the system, and the `delta` function updates the state of the system based on the elapsed time.\n\n#### Initialization\n\nThe system initializes with a specified number of philosophers (5 in this case), all in the thinking state, with no chopsticks being held at the start.\n\n#### Verification\n\nThe protocol includes predicates to verify the status of philosophers and their chopsticks, enabling checks to ensure that the system behaves as expected. Model checking is used to verify that no two philosophers hold the same chopstick simultaneously.\n\n---\n\n### Corresponding Maude File\n\nBased on the above description, the following is a simplified version of the Maude file that can be run by the Maude-NPA tool. This version encapsulates the main aspects of the Dining Philosophers protocol.\n\n```maude\nset show timing off .\nset show advisories off .\nset verbose on .\n\nfmod TIME is\n    sorts Time NzTime .\n    subsort NzTime < Time .\n\n    op zero : -> Time .\n    op _plus_ : Time Time -> Time [assoc comm prec 33 gather (E e)] .\n    op _monus_ : Time Time -> Time [prec 33 gather (E e)] .\n    op _le_ : Time Time -> Bool [prec 37] .\n    op _lt_ : Time Time -> Bool [prec 37] .\n    op _ge_ : Time Time -> Bool [prec 37] .\n    op _gt_ : Time Time -> Bool [prec 37] .\n\n    eq zero plus R:Time = R:Time .\n    eq R:Time le R':Time = (R:Time lt R':Time) or (R:Time == R':Time) .\n    eq R:Time ge R':Time = R':Time le R:Time .\n    eq R:Time gt R':Time = R':Time lt R:Time .\nendfm\n\nfmod DINING-PHILOSOPHERS is\n    protecting TIME .\n    \n    sort Status .\n    ops thinking hungry eating : -> Status .\n\n    ops EATING-TIME THINKING-TIME : -> Time .\n    eq EATING-TIME = 3 .\n    eq THINKING-TIME = 12 .\n\n    sort System .\n    op {_,_} : Configuration Time -> System .\n\n    class Philosopher | status : Status, chopsticks : Nat, timer : Time .\n    class Chopstick .\n\n    vars I J N : Nat .\n    vars Conf : Configuration .\n    vars T : Time .\n\n    rl [get-hungry] :\n        < I : Philosopher | status : thinking, timer : 0 > \n        => < I : Philosopher | status : hungry > .\n\n    crl [grab-stick] :\n        < I : Philosopher | status : hungry, chopsticks : N >\n        < J : Chopstick | >\n        => < I : Philosopher | chopsticks : s N >\n        if I == J or (s I == J or (I == 4 and J == 0)) .\n\n    rl [eat] :\n        < I : Philosopher | status : hungry, chopsticks : 2 >\n        => < I : Philosopher | status : eating, timer : EATING-TIME > .\n\n    rl [stop-eating] :\n        < I : Philosopher | status : eating, chopsticks : 0, timer : 0 >\n        => < I : Philosopher | status : thinking, chopsticks : 0, timer : THINKING-TIME >\n        < I : Chopstick | none >\n        < if I == 4 then 0 else s I fi : Chopstick | none > \n        [dnt] .\n\n    op initState : -> System .\n    op initState : Nat -> Configuration .\n    eq initState = { initState(5), 0 } .\n    eq initState(s N) \n        = < N : Philosopher | status : thinking, chopsticks : 0, timer : 0 >\n        < N : Chopstick | none > \n        initState(N) .\n    eq initState(0) = none .\n\nendfm\n\nred initState .\nsearch [1] initState =>! S:System .\n```",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 17:50:26 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in DINING-PHILOSOPHERS : initState .\nrewrites: 1\nresult System: {initState(5),0}\n==========================================\nsearch in DINING-PHILOSOPHERS : initState =>! S:System .\n\nSolution 1 (state 0)\nstates: 1  rewrites: 3\nS:System --> {initState(5),0}\nBye.Warning: \"dining-philosophers5.maude\", line 248 (omod DINING-PHILOSOPHERS):\n    syntax error\nWarning: \"dining-philosophers5.maude\", line 261 (omod DINING-PHILOSOPHERS): bad\n    token Philosopher.\nWarning: \"dining-philosophers5.maude\", line 260 (omod DINING-PHILOSOPHERS): no\n    parse for statement\nrl [get-hungry] : < I : Philosopher | status : thinking, timer : 0 > => < I :\n    Philosopher | status : hungry > .\nWarning: \"dining-philosophers5.maude\", line 264 (omod DINING-PHILOSOPHERS): bad\n    token Philosopher.\nWarning: \"dining-philosophers5.maude\", line 263 (omod DINING-PHILOSOPHERS): no\n    parse for statement\ncrl [grab-stick] : < I : Philosopher | status : hungry, chopsticks : N > < J :\n    Chopstick | > => < I : Philosopher | chopsticks : s N > if I == J or (s I\n    == J or (I == 4 and J == 0)) .\nWarning: \"dining-philosophers5.maude\", line 269 (omod DINING-PHILOSOPHERS): bad\n    token Philosopher.\nWarning: \"dining-philosophers5.maude\", line 268 (omod DINING-PHILOSOPHERS): no\n    parse for statement\nrl [eat] : < I : Philosopher | status : hungry, chopsticks : 2 > => < I :\n    Philosopher | status : eating, timer : EATING-TIME > .\nWarning: \"dining-philosophers5.maude\", line 272 (omod DINING-PHILOSOPHERS): bad\n    token P:Philosopher.\nWarning: \"dining-philosophers5.maude\", line 271 (omod DINING-PHILOSOPHERS): no\n    parse for statement\nrl [stop-eating] : < I : P:Philosopher | status : eating, chopsticks : 0, timer\n    : 0, Atts1 > => < I : P:Philosopher | status : thinking, chopsticks : 0,\n    timer : THINKING-TIME, Atts1 > < I : Chopstick | none > < if I == 4 then 0\n    else s I fi : Chopstick | none > [dnt] .\nWarning: \"dining-philosophers5.maude\", line 279 (omod DINING-PHILOSOPHERS): bad\n    token Philosopher.\nWarning: \"dining-philosophers5.maude\", line 279 (omod DINING-PHILOSOPHERS): no\n    parse for statement\neq mte (< I : Philosopher | timer : T, Atts1 > Conf) = minimum (T, mte (Conf))\n    .\nWarning: \"dining-philosophers5.maude\", line 284 (omod DINING-PHILOSOPHERS): bad\n    token Philosopher.\nWarning: \"dining-philosophers5.maude\", line 284 (omod DINING-PHILOSOPHERS): no\n    parse for statement\neq delta (< I : Philosopher | timer : T > Conf, T') = < I : Philosopher | timer\n    : T - T' > delta (Conf, T') .\nWarning: \"dining-philosophers5.maude\", line 296 (omod DINING-PHILOSOPHERS): bad\n    token Philosopher.\nWarning: \"dining-philosophers5.maude\", line 295 (omod DINING-PHILOSOPHERS): no\n    parse for statement\neq initState (s N) = < N : Philosopher | status : thinking, chopsticks : 0,\n    timer : 0 > < N : Chopstick | none > initState (N) .\nWarning: \"dining-philosophers5.maude\", line 306: unable to locate file:\n    model-checker.maude\nWarning: \"dining-philosophers5.maude\", line 309 (omod\n    DINING-PHILOSOPHERS-PREDS): module SATISFACTION does not exist.\nWarning: \"dining-philosophers5.maude\", line 310 (omod\n    DINING-PHILOSOPHERS-PREDS): undeclared sort State.\nWarning: \"dining-philosophers5.maude\", line 312 (omod\n    DINING-PHILOSOPHERS-PREDS): undeclared sort Prop.\nWarning: \"dining-philosophers5.maude\", line 321 (omod\n    DINING-PHILOSOPHERS-PREDS): bad token Philosopher.\nWarning: \"dining-philosophers5.maude\", line 321 (omod\n    DINING-PHILOSOPHERS-PREDS): no parse for statement\neq {< P : Philosopher | status : St > Conf, T} |= phil-status (P, St) = true .\nWarning: \"dining-philosophers5.maude\", line 322 (omod\n    DINING-PHILOSOPHERS-PREDS): bad token Philosopher.\nWarning: \"dining-philosophers5.maude\", line 322 (omod\n    DINING-PHILOSOPHERS-PREDS): no parse for statement\neq {< P : Philosopher | chopsticks : N > Conf, T} |= phil-sticks (P, N) = true\n    .\nWarning: \"dining-philosophers5.maude\", line 327 (omod\n    DINING-PHILOSOPHERS-5-CHECK): module MODEL-CHECKER does not exist.\nWarning: \"dining-philosophers5.maude\", line 328 (omod\n    DINING-PHILOSOPHERS-5-CHECK): module LTL-SIMPLIFIER does not exist.\nWarning: \"dining-philosophers5.maude\", line 331: bad token modelCheck.\nWarning: \"dining-philosophers5.maude\", line 331: no parse for term.\nWarning: \"dining-philosophers5-command\", line 4: bad token run.\nWarning: \"dining-philosophers5-command\", line 4: no parse for term.\nWarning: \"dining-philosophers5-command\", line 5: bad token initials.\nWarning: \"dining-philosophers5-command\", line 5: no parse for term.",
                0.6249408721923828
            ]
        ]
    },
    {
        "file": "MAUDE-1/diophantine.maude",
        "logic": "---\n\n### Protocol Description\n\n**Title:** Solving Systems of Linear Equations\n\n**Objective:** This protocol aims to demonstrate the use of the Maude-NPA tool to solve different systems of linear equations using methods analogous to those found in mathematical computation and algorithm design. The focus is primarily on two specific systems, showcasing the capabilities of Maude in handling complex algebraic structures.\n\n**Components:**\n1. **Linear Systems Representation:** Each system of linear equations is represented as a set of pairs, where each pair consists of two elements: a tuple representing the coefficients of the variables and a corresponding result (e.g., right-hand side of the equations). This is structured as `(x, y) |-> z`, indicating that the linear combination of the variables at positions `x` and `y` results in `z`.\n\n2. **Zero Vector:** The zero vector in the context of linear systems is a vector where all components are zero. It serves as the identity element in vector addition and is crucial for solving systems using methods such as Gaussian elimination or other matrix-based approaches.\n\n3. **Methodology:** The protocol employs the `natSystemSolve` function, which takes in a representation of a linear system, a zero vector, and a string identifier for the solving method (e.g., \"cd\" for column-decomposition, \"gcd\" for greatest common divisor). The method specified determines the algorithm used to find solutions to the system.\n\n**Examples:**\n1. **First Example (Domenjoud's 10 Solution System):**\n   - This example represents a specific linear system with integer solutions. The pairs represent the coefficients and their corresponding results, indicating a scenario where multiple solutions are possible.\n   - Input: \n     ```\n     (0,0) |-> 1 ; (0,1) |-> 2 ; (0,2) |-> -3 ; (0,3) |-> -2 ; (0,4) |-> -4 ;\n     (1,0) |-> 2 ; (1,1) |-> -1 ; (1,2) |-> -3 ; (1,3) |-> 2 ; (1,4) |-> 5\n     ```\n\n2. **Second Example (Sailors and Monkey):**\n   - This example illustrates a more complex system involving multiple variables and their interdependencies. It highlights the challenges in solving systems with negative coefficients and the constraints that can arise.\n   - Input:\n     ```\n     (0,0) |-> 1 ; (0,1) |-> -5 ;\n     (1,1) |-> 4 ; (1,2) |-> -5 ;\n     (2,2) |-> 4 ; (2,3) |-> -5 ;\n     (3,3) |-> 4 ; (3,4) |-> -5 ;\n     (4,4) |-> 4 ; (4,5) |-> -5 ;\n     (5,5) |-> 4 ; (5,6) |-> -5\n     ```\n\n**Execution Environment:**\n- The protocol is implemented in the Maude language, which supports high-level programming and formal specification. It is designed to facilitate the execution of algebraic computations, allowing users to solve complex systems of equations efficiently.\n\n**Conclusion:**\nThis protocol serves as a foundational approach to solving linear systems using Maude-NPA. The examples provided illustrate different scenarios and complexity levels, showcasing the versatility of the tool. Users can modify or extend the existing systems to explore further mathematical problems or test new solving techniques.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.6 built: Dec  9 2010 18:28:39\n\t    Copyright 1997-2010 SRI International\n\t\t   Thu May 22 09:44:22 2025\n\n\t    Maude-NPA Version: 11/26/2011\n\t    Copyright (c) 2012, University of Illinois\n\t    All rights reserved.\n\n==========================================\nreduce in DIOPHANTINE : natSystemSolve(0,0 |-> 1 ; 0,1 |-> 2 ; 0,2 |-> -3 ; 0,3\n    |-> -2 ; 0,4 |-> -4 ; 1,0 |-> 2 ; 1,1 |-> -1 ; 1,2 |-> -3 ; 1,3 |-> 2 ; 1,4\n    |-> 5, zeroVector, \"cd\") .\nrewrites: 1\nresult IntVectorSetPair: [\n  zeroVector\n|\n  0 |-> 9 ; 1 |-> 3 ; 2 |-> 5,\n  1 |-> 9 ; 2 |-> 2 ; 4 |-> 3,\n  1 |-> 12 ; 2 |-> 2 ; 3 |-> 9,\n  0 |-> 1 ; 1 |-> 3 ; 2 |-> 1 ; 3 |-> 2,\n  0 |-> 3 ; 1 |-> 7 ; 2 |-> 3 ; 4 |-> 2,\n  0 |-> 5 ; 1 |-> 3 ; 2 |-> 3 ; 3 |-> 1,\n  0 |-> 6 ; 1 |-> 5 ; 2 |-> 4 ; 4 |-> 1,\n  1 |-> 10 ; 2 |-> 2 ; 3 |-> 3 ; 4 |-> 2,\n  1 |-> 11 ; 2 |-> 2 ; 3 |-> 6 ; 4 |-> 1,\n  0 |-> 2 ; 1 |-> 5 ; 2 |-> 2 ; 3 |-> 1 ; 4 |-> 1\n]\n==========================================\nreduce in DIOPHANTINE : natSystemSolve(0,0 |-> 1 ; 0,1 |-> -5 ; 1,1 |-> 4 ; 1,2\n    |-> -5 ; 2,2 |-> 4 ; 2,3 |-> -5 ; 3,3 |-> 4 ; 3,4 |-> -5 ; 4,4 |-> 4 ; 4,5\n    |-> -5 ; 5,5 |-> 4 ; 5,6 |-> -5, 0 |-> 1 ; 1 |-> 1 ; 2 |-> 1 ; 3 |-> 1 ; 4\n    |-> 1 ; 5 |-> 1, \"gcd\") .\nrewrites: 1\nresult IntVectorSetPair: [\n  0 |-> 15621 ; 1 |-> 3124 ; 2 |-> 2499 ; 3 |-> 1999 ; 4 |-> 1599 ; 5 |-> 1279\n    ; 6 |-> 1023\n|\n  0 |-> 15625 ; 1 |-> 3125 ; 2 |-> 2500 ; 3 |-> 2000 ; 4 |-> 1600 ; 5 |-> 1280\n    ; 6 |-> 1024\n]\nBye.",
                0.6798701286315918
            ]
        ]
    },
    {
        "file": "MAUDE-1/doubleAttributeFebruary2023.maude",
        "logic": "The Maude-NPA (Nondeterministic Protocol Analyzer) tool allows you to analyze cryptographic protocols by modeling them in the Maude language. Based on the provided Maude file, we can describe the protocol as follows:\n\n---\n\n### Protocol Description\n\n**Protocol Name:** FOO\n\n**Purpose:** The FOO protocol is designed to illustrate the behavior of a function defined with a double iteration attribute in a formal system. It serves as a test case for analyzing how the Maude-NPA tool handles such constructs.\n\n**Components:**\n\n1. **Sort Definition:**\n   - The protocol defines a sort named `Foo`. This represents a basic data type that will be used within the operations of the protocol.\n\n2. **Operation Definition:**\n   - The protocol includes a single operation `f`, which takes an element of type `Foo` as input and returns an element of type `Foo`. The operation is defined with a double iteration attribute, denoted as `[iter iter]`. This means that the operation can be applied multiple times in succession, allowing for repeated applications of `f` to its result.\n\n**Behavior:**\n- The operation `f` can be executed repeatedly, leading to a potentially complex structure of nested applications. This is useful for testing the capabilities of the Maude-NPA tool in handling operations with multiple iterations.\n\n**Intended Analysis:**\n- The main goal of this protocol is to assess how the Maude-NPA tool interprets and processes operations with the double iteration attribute. This includes analyzing possible behaviors, potential warnings, and ensuring that the operational semantics align with the expected outcomes.\n\n---\n\n### Corresponding Maude File\n\nThe following Maude code represents the structure and behavior of the FOO protocol as described:\n\n```maude\nfmod FOO is\n  sort Foo .\n  op f : Foo -> Foo [iter iter] .\nendfm\n```\n\nThis Maude file can be executed in the Maude-NPA tool to explore the defined operation and understand its implications in the context of cryptographic protocol analysis. \n\n### Usage in Maude-NPA\n\nTo run this protocol in the Maude-NPA tool, you would typically load the Maude file and then invoke the appropriate commands to analyze the operation `f`, particularly focusing on its behavior under multiple iterations. You might check for various properties, such as termination, reachability, and the presence of any vulnerabilities that could arise from the iterative nature of the function.\n\n---\n\nThis description content provides a clear understanding of the FOO protocol and facilitates generating the corresponding Maude file that can be used in the Maude-NPA tool.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 19:39:51 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"doubleAttributeFebruary2023-command\", line 4: bad token run.\nWarning: \"doubleAttributeFebruary2023-command\", line 4: no parse for term.\nWarning: \"doubleAttributeFebruary2023-command\", line 5: bad token initials.\nWarning: \"doubleAttributeFebruary2023-command\", line 5: no parse for term.",
                0.5792458057403564
            ]
        ]
    },
    {
        "file": "MAUDE-1/Example1.maude",
        "logic": "### Protocol Description\n\n#### Context\nIn this protocol, we are analyzing the behavior of a node \\( N \\) that is in a \"waiting\" state and is performing a lookup operation on a variable \\( X \\). The node will evaluate the result of the lookup and assign it to a local variable \\( x \\).\n\n#### Node Definition\n- **Node \\( N \\)**: This node is responsible for executing a lookup operation to retrieve the current value of a variable \\( X \\). The node's execution context is defined by various conditions that govern its behavior.\n\n#### Lookup Operation\n- The node executes the operation:\n  ```maude\n  x := LookUpNow(X);\n  ```\n  This means that at this point, node \\( N \\) is trying to obtain the value of \\( X \\) immediately.\n\n#### Assumptions\n1. The protocol assumes that there are **no other lookup operations** on variable \\( X \\) at the same time.\n2. The value obtained from the lookup operation is determined by the function \\( Sigma(i, X) \\), which is presumed to return the current value associated with \\( X \\).\n\n#### Execution Outcome\n- Since there are no monitors on variable \\( X \\), the execution of node \\( N \\) results in:\n  - The local variable \\( x \\) being assigned the value \\( Sigma(i, X) \\).\n  - The lookup operation evaluates to \\( Gamma(i, X) \\), which, by definition in this context, is equivalent to \\( Sigma(i, X) \\).\n\n#### Global State\n- The global state of the protocol is defined as follows:\n  - The node \\( N \\) is in an assignment state with specific parameters that dictate its behavior:\n    - **Status**: waiting\n    - **Outcome**: none\n    - **Active**: true\n    - **Condition Flags**: various flags controlling the node's execution (e.g., start condition, end condition, and post conditions).\n  - The variable \\( x \\) is categorized as memory with initial and active values.\n\n### Maude File Structure\nThe provided Maude file defines the following components:\n- **Module Declaration**: The module is defined as `EXAMPLE1`, which includes the protection of `PLEXILITE-PREDS`.\n- **Operations**:\n  - `Example1`: Represents the node's behavior and the lookup assignment.\n  - `Example1Env`: Defines the environment context containing the variable \\( X \\).\n  - `stateN`: Configures the global state of the protocol, capturing the current status of node \\( N \\) and the memory state of variable \\( x \\).\n\n### Execution\nThe execution of the protocol can be initiated using the command:\n```maude\nsrew stateN using micro ! .\n```\nThis command will simulate the execution of the protocol, allowing the Maude-NPA tool to analyze the behavior of the node and the interactions with the variable \\( X \\).\n\n### Summary\nThis protocol serves as a foundational example for demonstrating how a node can look up values in a shared context and how the state of the node can be represented and simulated using the Maude-NPA tool. The absence of concurrent lookups ensures that the lookup operation is straightforward, leading to predictable behavior in the protocol's execution.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Tue May 20 22:48:00 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"Example1.maude\", line 21 (mod EXAMPLE1): module PLEXILITE-PREDS does\n    not exist.\nWarning: \"Example1.maude\", line 23 (mod EXAMPLE1): undeclared sort Plexil.\nWarning: \"Example1.maude\", line 41 (mod EXAMPLE1): undeclared sort ContextList.\nWarning: \"Example1.maude\", line 44 (mod EXAMPLE1): undeclared sort\n    GlobalConfig.\nWarning: \"Example1.maude\", line 24 (mod EXAMPLE1): bad token assignment.\nWarning: \"Example1.maude\", line 24 (mod EXAMPLE1): no parse for statement\neq Example1 = assignment ('N, ('x : v (0)), ((startc: const (v (true))), (endc:\n    const (v (true))), (repeatc: const (v (false))), (inv: const (v (true))), (\n    post: const (v (true))), (pre: const (v (true))), (skip: const (v (\n    false))), (priority: 1)), (('x . 'N) := (lookup ('X)))) .\nWarning: \"Example1.maude\", line 42 (mod EXAMPLE1): bad token v.\nWarning: \"Example1.maude\", line 42 (mod EXAMPLE1): no parse for statement\neq Example1Env = ('X : v (1)) .\nWarning: \"Example1.maude\", line 46 (mod EXAMPLE1): bad token {.\nWarning: \"Example1.maude\", line 45 (mod EXAMPLE1): no parse for statement\neq stateN = {nilcontexts} > 'X : v (1) |- [< 'N : assignment | status: waiting,\n    outcome: none, active: true, repeatc: const (v (false)), startc: const (v (\n    true)), endc: const (v (true)), post: const (v (true)), skip: const (v (\n    false)), pre: const (v (true)), inv: const (v (true)), priority: 1,\n    loopenabled: true, ('x . 'N) := lookup ('X) > < 'x . 'N : memory | initVal:\n    v (0), actVal: v (0) >] {mtactions} {\"inactive-03\"} .\nWarning: \"Example1-command\", line 4: bad token run.\nWarning: \"Example1-command\", line 4: no parse for term.\nWarning: \"Example1-command\", line 5: bad token initials.\nWarning: \"Example1-command\", line 5: no parse for term.",
                0.6302318572998047
            ]
        ]
    },
    {
        "file": "MAUDE-1/Example3.maude",
        "logic": "---\n\n### Protocol Description: Example3\n\n#### Overview\nThe protocol `Example3` is designed to monitor the state of a variable `X` and perform assignment operations based on its value. It leverages monitoring conditions to determine when to update the variable `x` within the node `N`.\n\n#### Node Definition\n- **Node Name:** `N`\n- **Start Condition:** The protocol begins execution only when the lookup on `X` for the last 5 time units (i.e., `LookUpOnChange(X, 5)`) is greater than or equal to 9. This condition ensures that the protocol will not proceed unless there has been a significant change in the monitored variable `X` over the specified period.\n  \n- **Variable Assignment:** The variable `x` is assigned the current value of `X` using the function `LookUpNow(X)`. \n\n#### Execution Logic\n1. **Initial State:** Assume `Sigma(i, X) = 8` and `Gamma(i-1, X) = 11`.\n2. **Monitor Behavior:** The monitor on `X` does not hold true at the current time (i.e., it is not in a state of significant change), leading to the conclusion that `Gamma(i, X)` will take the value of `Gamma(i-1, X)`, which is 11.\n3. **Evaluation of Functions:**\n   - Both `LookUpOnChange(X, 5)` and `LookUpNow(X)` will evaluate to `Gamma(i, X)`, which is 11.\n4. **End State:** The execution of node `N` concludes with the variable `x` holding the value 11, despite the \"real\" value of `X` being `Sigma(i, X) = 1`, which is less than the required threshold for the start condition.\n\n#### Context Environment\nThe environment for the protocol is defined with multiple states of `X`, specifically:\n- `X` can take values of 3, 7, or 11. This demonstrates that `X` can change over time and that the protocol must adapt to these changes.\n\n#### Execution Commands\n- The protocol can be executed and compiled using the commands provided, utilizing the Maude-NPA tool's capabilities for simulation and analysis of the protocol behavior regarding state changes and variable assignments.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Thu May 22 10:24:33 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"Example3.maude\", line 20 (mod EXAMPLE3): module PLEXILITE-PREDS does\n    not exist.\nWarning: \"Example3.maude\", line 22 (mod EXAMPLE3): undeclared sort Plexil.\nWarning: \"Example3.maude\", line 40 (mod EXAMPLE3): undeclared sort ContextList.\nWarning: \"Example3.maude\", line 23 (mod EXAMPLE3): bad token assignment.\nWarning: \"Example3.maude\", line 23 (mod EXAMPLE3): no parse for statement\neq Example3 = assignment ('N, ('x : v (0)), ((startc: lookupOnChange ('X, v (\n    5)) >= const (v (9))), (endc: const (v (true))), (repeatc: const (v (\n    false))), (inv: const (v (true))), (post: const (v (true))), (pre: const (v\n    (true))), (skip: const (v (false))), (priority: 1)), (('x . 'N) := (lookup\n    ('X)))) .\nWarning: \"Example3.maude\", line 41 (mod EXAMPLE3): bad token v.\nWarning: \"Example3.maude\", line 41 (mod EXAMPLE3): no parse for statement\neq Example3Env = ('X : v (3)) # ('X : v (7)) # ('X : v (11)) .\nWarning: \"Example3-command\", line 4: bad token run.\nWarning: \"Example3-command\", line 4: no parse for term.\nWarning: \"Example3-command\", line 5: bad token initials.\nWarning: \"Example3-command\", line 5: no parse for term.",
                0.6776912212371826
            ]
        ]
    },
    {
        "file": "MAUDE-1/fakeParameterConstant.maude",
        "logic": "---\n\n### Description of the Protocol\n\n#### Overview\nThis protocol is designed to test the behavior of constant parameters in the Maude-NPA (Nondeterministic Protocol Analyzer) framework. Specifically, it examines the distinction between a fake parameter constant and a legitimate constant, ensuring that the fake parameter constant is not incorrectly treated as a true constant within the system.\n\n#### Components of the Protocol\n\n1. **Theory Definition**:\n   - The file begins with the definition of a theory called `T`. \n   - Within this theory, a single sort `Elt` is defined, representing elements in the theory.\n   - A constant `c` of sort `Elt` is declared as a parameter constant using the `[pconst]` attribute. This indicates that `c` behaves like a constant that can be used in parameterized modules but does not have a specific value.\n\n   ```maude\n   fth T is\n     sort Elt .\n     op c : -> Elt [pconst] .\n   endfth\n   ```\n\n2. **Module FOO**:\n   - The module `FOO` is parameterized by the theory `T`, represented by `Y`. \n   - It introduces a new constant `d` of sort `Elt`, also declared as a parameter constant.\n   - An equation is defined stating that the parameter constant `c` is equal to the new parameter constant `d`. This equation is crucial for testing purposes, as it establishes a relationship between the two constants.\n\n   ```maude\n   fmod FOO{X :: T} is\n     op X$d : -> X$Elt [pconst] .\n     eq X$c = X$d .\n   endfm\n   ```\n\n3. **Module BAR**:\n   - The `BAR` module includes the `FOO` module, effectively incorporating its definitions and behaviors.\n   - This module serves as a test bed for analyzing the properties and interactions of the constants defined in `FOO` and their treatment as parameter constants.\n\n   ```maude\n   fmod BAR{Y :: T} is\n     inc FOO{Y} .\n   endfm\n   ```\n\n4. **Execution Command**:\n   - The command `show all .` at the end of the file instructs Maude to display all the definitions, equations, and constants that have been declared in the modules.\n\n#### Purpose\nThe primary purpose of this protocol is to verify that the fake parameter constant, represented here as `c`, is treated distinctly from actual constants in the protocol. This testing ensures that the behavior of constants is correctly implemented in the Maude-NPA framework, allowing for accurate modeling and analysis of cryptographic protocols.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Thu May 22 10:24:37 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nfmod BAR{Y :: T} is\n  sorts Y$Elt Bool .\n  op if_then_else_fi : Bool Universal Universal -> Universal [poly (2 3 0) prec\n    0 gather (& & &) special (\n    id-hook BranchSymbol\n    term-hook 1 (true)\n    term-hook 2 (false))] .\n  op _==_ : Universal Universal -> Bool [poly (1 2) prec 51 gather (E E)\n    special (\n    id-hook EqualitySymbol\n    term-hook equalTerm (true)\n    term-hook notEqualTerm (false))] .\n  op _=/=_ : Universal Universal -> Bool [poly (1 2) prec 51 gather (E E)\n    special (\n    id-hook EqualitySymbol\n    term-hook equalTerm (false)\n    term-hook notEqualTerm (true))] .\n  op c : -> Y$Elt .\n  op true : -> Bool [ctor special (\n    id-hook SystemTrue)] .\n  op false : -> Bool [ctor special (\n    id-hook SystemFalse)] .\n  op _and_ : Bool Bool -> Bool [assoc comm prec 55 gather (e E)] .\n  op _or_ : Bool Bool -> Bool [assoc comm prec 59 gather (e E)] .\n  op _xor_ : Bool Bool -> Bool [assoc comm prec 57 gather (e E)] .\n  op not_ : Bool -> Bool [prec 53 gather (E)] .\n  op _implies_ : Bool Bool -> Bool [prec 61 gather (e E)] .\n  op X$d : -> Y$Elt .\n  eq true and A:Bool = A:Bool .\n  eq false and A:Bool = false .\n  eq A:Bool and A:Bool = A:Bool .\n  eq false xor A:Bool = A:Bool .\n  eq A:Bool xor A:Bool = false .\n  eq A:Bool and (B:Bool xor C:Bool) = A:Bool and B:Bool xor A:Bool and C:Bool .\n  eq not A:Bool = true xor A:Bool .\n  eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .\n  eq A:Bool implies B:Bool = not (A:Bool xor A:Bool and B:Bool) .\nendfm\nBye.Warning: \"fakeParameterConstant.maude\", line 7 (fth T): syntax error\nWarning: \"fakeParameterConstant.maude\", line 11 (fmod FOO): syntax error\nWarning: \"fakeParameterConstant.maude\", line 12 (fmod FOO): bad token X$c.\nWarning: \"fakeParameterConstant.maude\", line 12 (fmod FOO): no parse for\n    statement\neq X$c = X$d .\nWarning: \"fakeParameterConstant-command\", line 4: bad token run.\nWarning: \"fakeParameterConstant-command\", line 4: no parse for term.\nWarning: \"fakeParameterConstant-command\", line 5: bad token initials.\nWarning: \"fakeParameterConstant-command\", line 5: no parse for term.",
                0.7290244102478027
            ]
        ]
    },
    {
        "file": "MAUDE-1/fakeParameterSort.maude",
        "logic": "---\n\n## Protocol Description\n\n### Overview\nThe provided Maude code defines a modular structure with an emphasis on parameterized sorts and their relationships. The goal is to test that a specific parameter sort (in this case, a fake parameter sort) is not treated as a legitimate sort in a given context.\n\n### Components\n\n1. **Theory Definition (`T`)**:\n   - A theory `T` is defined, which introduces a sort `Elt`. This sort serves as a base element that other sorts can derive from.\n\n   ```maude\n   fth T is\n     sort Elt .\n   endfth\n   ```\n\n2. **Module Definition (`FOO`)**:\n   - A parameterized module `FOO` is defined, which takes a parameter `X` that is constrained to the theory `T`.\n   - Inside `FOO`, a new sort `X$Foo` is defined. This sort is a specific type associated with the parameter `X`.\n   - Additionally, a subsort relationship is established, indicating that `X$Foo` is a subtype of `X$Elt`. This means that any element of sort `X$Foo` can be treated as an element of sort `X$Elt`.\n\n   ```maude\n   fmod FOO{X :: T} is\n     sort X$Foo .\n     subsort X$Foo < X$Elt .\n   endfm\n   ```\n\n3. **Module Definition (`BAR`)**:\n   - Another module, `BAR`, is defined, which also takes a parameter `Y` constrained to the same theory `T`.\n   - The module `BAR` includes the module `FOO` with the parameter `Y`. This indicates that `BAR` can utilize the definitions within `FOO`, specifically using `Y` as the parameter for `FOO`.\n\n   ```maude\n   fmod BAR{Y :: T} is\n     inc FOO{Y} .\n   endfm\n   ```\n\n### Purpose\nThe primary purpose of this code is to demonstrate the handling of parameter sorts in Maude. By ensuring that the fake parameter sort does not get treated as a legitimate sort, it allows for testing the integrity of the sort relationships defined in the modules. The `show all` command at the end of the script is used to display all the sorts and their relationships defined in the modules.\n\n### Conclusion\nThis protocol illustrates the use of parameterized modules in Maude, specifically focusing on the relationships between sorts and the significance of ensuring that certain parameters are not misclassified. The modular design allows for extensibility and clarity in how sorts are defined and related.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 13:21:40 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nfmod BAR{Y :: T} is\n  sorts Y$Elt Bool X$Foo .\n  subsort X$Foo < Y$Elt .\n  op if_then_else_fi : Bool Universal Universal -> Universal [poly (2 3 0) prec\n    0 gather (& & &) special (\n    id-hook BranchSymbol\n    term-hook 1 (true)\n    term-hook 2 (false))] .\n  op _==_ : Universal Universal -> Bool [poly (1 2) prec 51 gather (E E)\n    special (\n    id-hook EqualitySymbol\n    term-hook equalTerm (true)\n    term-hook notEqualTerm (false))] .\n  op _=/=_ : Universal Universal -> Bool [poly (1 2) prec 51 gather (E E)\n    special (\n    id-hook EqualitySymbol\n    term-hook equalTerm (false)\n    term-hook notEqualTerm (true))] .\n  op true : -> Bool [ctor special (\n    id-hook SystemTrue)] .\n  op false : -> Bool [ctor special (\n    id-hook SystemFalse)] .\n  op _and_ : Bool Bool -> Bool [assoc comm prec 55 gather (e E)] .\n  op _or_ : Bool Bool -> Bool [assoc comm prec 59 gather (e E)] .\n  op _xor_ : Bool Bool -> Bool [assoc comm prec 57 gather (e E)] .\n  op not_ : Bool -> Bool [prec 53 gather (E)] .\n  op _implies_ : Bool Bool -> Bool [prec 61 gather (e E)] .\n  eq true and A:Bool = A:Bool .\n  eq false and A:Bool = false .\n  eq A:Bool and A:Bool = A:Bool .\n  eq false xor A:Bool = A:Bool .\n  eq A:Bool xor A:Bool = false .\n  eq A:Bool and (B:Bool xor C:Bool) = A:Bool and B:Bool xor A:Bool and C:Bool .\n  eq not A:Bool = true xor A:Bool .\n  eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .\n  eq A:Bool implies B:Bool = not (A:Bool xor A:Bool and B:Bool) .\nendfm\nBye.Warning: \"fakeParameterSort-command\", line 4: bad token run.\nWarning: \"fakeParameterSort-command\", line 4: no parse for term.\nWarning: \"fakeParameterSort-command\", line 5: bad token initials.\nWarning: \"fakeParameterSort-command\", line 5: no parse for term.",
                0.6297883987426758
            ]
        ]
    },
    {
        "file": "MAUDE-1/filteredVariantUnifyJune2023.maude",
        "logic": "Based on the provided Maude file, the protocol seems to involve a stack manipulation system with specific operations and properties. I will describe the protocol in a structured manner, which can later be used to generate a corresponding Maude file.\n\n---\n\n### Protocol Description: SUB-STACK\n\n#### Overview\nThe SUB-STACK protocol defines a simple stack data structure with operations for constructing natural numbers and stacks, as well as operations for combining stacks. The primary focus is on how stacks can be manipulated and combined, along with an important equation that relates to the combination of stacks.\n\n#### Sorts\n- **Nat**: Represents natural numbers.\n- **Stk**: Represents stack data structures, which are a subtype of natural numbers.\n\n#### Operations\n1. **Natural Number Operations**:\n   - **0**: A constructor for the natural number zero.\n   - **s**: A constructor for the successor of a natural number.\n\n2. **Stack Operations**:\n   - **emp**: The empty stack constructor.\n   - **mk**: A constructor for creating a stack from a natural number.\n   - **_*_**: A binary operation for combining two stacks, which is associative and has an identity element (empty stack).\n   - **_+_**: A binary operation for adding two stacks, which is commutative and associative.\n\n#### Variables\n- **X, Y**: Variables of sort Stk which represent stacks.\n\n#### Equations\n- **Substitution Equation**: The protocol includes a critical equation that states:\n  \\[\n  (X * Y) + X = X\n  \\]\n  This equation is essential for understanding how stacks interact under the defined operations, specifically how combining stacks with a certain configuration results in a simplification to just one of the stacks.\n\n#### Properties\n- The protocol specifies a **variant** operation that checks for unification of stacks. The expression `R:Stk =? S:Stk + T:Stk` is intended to explore if two stack structures can be made equivalent under the defined operations.\n- A filtered variant operation is also noted, which highlights issues related to termination and the complexity involved in tracking substitutions during the unification process.\n\n### Conclusion\nThe SUB-STACK protocol showcases a fundamental interaction of stack operations within the context of natural numbers. The main focus is on combining stacks and understanding their properties through the defined operations and equations. This protocol can be extended and tested using the Maude-NPA tool for further formal analysis.\n\n---\n\nThis description captures the essence of the SUB-STACK protocol and can be used as a foundation for generating a Maude file for implementation or further experimentation within the Maude-NPA framework.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 22:49:12 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nvariant unify in SUB-STACK : R:Stk =? S:Stk + T:Stk  .\n\nUnifier #1\nrewrites: 0\nR:Stk --> %1:Stk + %2:Stk\nS:Stk --> %1:Stk\nT:Stk --> %2:Stk\n\nNo more unifiers.\nrewrites: 0\n==========================================\nvariant unify in SUB-STACK : R:Stk =? S:Stk + T:Stk  .\n\nUnifier #1\nrewrites: 0\nR:Stk --> %1:Stk + %2:Stk\nS:Stk --> %1:Stk\nT:Stk --> %2:Stk\n\nNo more unifiers.\nrewrites: 0\nBye.Warning: Term X * Y is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"filteredVariantUnifyJune2023.maude\", line 21 (fmod SUB-STACK):\n    lefthand side of eq X + X * Y = X [variant label sub] . contains function\n    symbols with nonvariable arguments that are not supported by unification.\nWarning: Unification modulo the theory of operator _*_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _*_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _*_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _*_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _*_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _*_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _*_ is not currently\n    supported.\nWarning: \"filteredVariantUnifyJune2023.maude\", line 28: skipped unexpected\n    token: filtered\nWarning: Unification modulo the theory of operator _*_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _*_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _*_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _*_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _*_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _*_ is not currently\n    supported.\nWarning: Unification modulo the theory of operator _*_ is not currently\n    supported.\nWarning: \"filteredVariantUnifyJune2023-command\", line 4: bad token run.\nWarning: \"filteredVariantUnifyJune2023-command\", line 4: no parse for term.\nWarning: \"filteredVariantUnifyJune2023-command\", line 5: bad token initials.\nWarning: \"filteredVariantUnifyJune2023-command\", line 5: no parse for term.",
                0.678865909576416
            ]
        ]
    },
    {
        "file": "MAUDE-1/generatedByFebruary2023.maude",
        "logic": "### Protocol Description\n\nThis Maude file defines a simple functional module named `FOO`, which contains a single equation. The equation states that the number `5` is equivalent to the number `1`. This is an example of creating a trivial equation within the Maude framework. \n\nThe `generated-by` statement indicates that the module is generated by the `NAT` module, which is typically used for natural numbers in Maude. This implies that the equations defined in this module can be understood in the context of natural numbers.\n\nThe `show desugared` command at the end is used to display the desugared version of the module, which helps in understanding how Maude interprets the module structure and the relationships between the statements.\n\n### Corresponding Maude File\n\nBased on the above description, the following is the corresponding Maude file that can be run by Maude-NPA:\n\n```maude\nfmod FOO is\n  -- Define a simple equation stating that 5 is equivalent to 1\n  eq 5 = 1 .\n\n  -- Indicate that this module is generated by the NAT module for natural numbers\n  generated-by NAT .\nendfm\n\n-- Show the desugared version of the module for clarity\nshow desugared .\n```\n\n### Key Components\n\n1. **Module Declaration (`fmod FOO is ... endfm`)**: Defines the module `FOO`.\n2. **Equation (`eq 5 = 1`)**: Sets a trivial equality between two numbers.\n3. **Generated-By (`generated-by NAT`)**: Indicates that this module is built upon the `NAT` module.\n4. **Show Command (`show desugared`)**: Displays the internal structure of the module after desugaring.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 22:48:19 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"generatedByFebruary2023.maude\", line 7 (fmod FOO): bad token\n    generated-by.\nWarning: \"generatedByFebruary2023.maude\", line 6 (fmod FOO): no parse for\n    statement\neq 5 = 1 . generated-by NAT .\nWarning: \"generatedByFebruary2023.maude\", line 10: skipped unexpected token:\n    desugared\nWarning: \"generatedByFebruary2023.maude\", line 10: syntax error\nWarning: \"generatedByFebruary2023-command\", line 4: bad token run.\nWarning: \"generatedByFebruary2023-command\", line 4: no parse for term.\nWarning: \"generatedByFebruary2023-command\", line 5: bad token initials.\nWarning: \"generatedByFebruary2023-command\", line 5: no parse for term.",
                0.6295647621154785
            ]
        ]
    },
    {
        "file": "MAUDE-1/hf-sets.maude",
        "logic": "---\n\n### Protocol Description: HF-SETS\n\n**Purpose**: The `HF-SETS` module defines a formal framework for manipulating sets and their properties in a way that supports algebraic operations, particularly in the context of set theory.\n\n#### Components\n\n1. **Sorts**:\n   - **Magma**: A general term for a set equipped with a binary operation.\n   - **Set**: A specific type of Magma that represents a collection of elements.\n\n2. **Operations**:\n   - **Binary Operations**: Defined for `Magma`, allowing for the construction of ordered pairs.\n   - **Set Constructor**: `{}` denotes the empty set, and `{M}` creates a singleton set from an element `M`.\n\n3. **Equations**:\n   - **Idempotent Law**: `S U S = S` (union of a set with itself is the set).\n   - **Membership**: Defines whether an element belongs to a set using `_in_`.\n   - **Set Equality**: Two sets are equal if they contain the same elements.\n   - **Set Containment**: A set is contained within another if all its elements are also in the other set.\n   - **Union**: The union operation combines elements from two sets.\n   - **Powerset**: The operation `P` generates the powerset of a given set, which includes all subsets.\n   - **Augmentation**: Augments a set with an additional element, creating new subsets.\n   - **Intersection**: The intersection of two sets is defined along with conditions for checking membership.\n\n4. **Critical Pairs**:\n   - The module includes critical pairs that must be checked for joinability to ensure that the definitions are coherent and do not lead to inconsistencies.\n\n5. **Extending the Module**:\n   - The `HF-SETS-1`, `HF-SETS-2`, and `HF-SETS-3` modules build upon `HF-SETS` by adding new equations that address identified critical pairs, ensuring properties such as commutativity and associativity are preserved across operations.\n\n#### Key Properties\n- **Associativity**: Operations such as union and intersection are associative, meaning the grouping of the operation does not affect the result.\n- **Commutativity**: The order in which sets are combined does not change the outcome (e.g., `S U T = T U S`).\n- **Closure**: The operations defined ensure that the resulting sets remain within the defined sort of `Set`.\n\n#### Goals\n- To provide a clear and formal framework for reasoning about sets and their relationships.\n- To ensure that all operations and properties defined are valid through rigorous algebraic proofs.\n\n### Conclusion\nThis description encapsulates the functionality and structure of the `HF-SETS` module in Maude. By following this outline, one can generate a corresponding Maude file that defines a coherent and robust set theory framework suitable for further analysis and computation.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Thu May 22 09:44:04 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"hf-sets-command\", line 4: bad token run.\nWarning: \"hf-sets-command\", line 4: no parse for term.\nWarning: \"hf-sets-command\", line 5: bad token initials.\nWarning: \"hf-sets-command\", line 5: no parse for term.",
                0.627784013748169
            ]
        ]
    },
    {
        "file": "MAUDE-1/identityUnificationMay2020.maude",
        "logic": "### Protocol Description for the Maude-NPA File\n\n#### Overview\nThe provided Maude file is a test case designed to explore unification issues within the context of a specific algebraic structure. The focus of this protocol is on verifying the behavior of unification involving a mix of different variable types, specifically addressing a potential bug when original variables are used instead of their representative counterparts.\n\n#### Components of the Protocol\n\n1. **Sorts and Subsorts**:\n   - The protocol defines two sorts: `Small` and `Foo`.\n   - It establishes a subsort relationship where `Small` is a subtype of `Foo`. This means that every instance of `Small` can be treated as an instance of `Foo`, but not vice versa.\n\n2. **Operations**:\n   - The protocol includes the following operations:\n     - `1`: This is a nullary operation (i.e., it takes no arguments) and returns an element of type `Foo`. It serves as an identity element in the algebraic structure.\n     - `f`: This is a binary operation that takes two arguments of type `Foo` and returns a value of type `Foo`. It is defined to be associative, with `1` acting as its identity element.\n     - `g`: This is a unary operation that takes one argument of type `Foo` and returns another value of type `Foo`.\n\n3. **Variables**:\n   - The protocol utilizes three variables `X`, `Y`, and `Z`, all of which are of type `Foo`. Additionally, there is a variable `S` of type `Small`.\n\n4. **Unification Statement**:\n   - The core of the protocol is the unification statement, which attempts to unify two expressions:\n     - `Z` is unified with `f(X, Y)`.\n     - The expression `g(Z)` is unified with `g(S)`.\n   - The unification process checks whether these expressions can be made equivalent under the given definitions and operations.\n\n5. **Variant**:\n   - A variant of the unification statement is provided. The purpose of this is to check if the unification can be performed without resulting in infinite descent or other non-terminating processes, ensuring that the system remains sound and consistent.\n\n#### Objective\nThe primary goal of this Maude-NPA protocol is to test the unification mechanism for potential bugs related to variable handling. Specifically, it investigates the implications of using the original variables versus their representatives in the unification process, ensuring that the Maude-NPA tool correctly handles such cases.\n\n#### Conclusion\nThis protocol serves as a foundational test case for examining the behavior of unification within a custom algebraic structure defined in Maude. It allows for the exploration of variable interactions and potential issues in the unification process, providing valuable insights into the functionality of the Maude-NPA tool.\n\n--- \n\nBased on this description, a corresponding Maude file can be generated that adheres to the structure and operations outlined above, ensuring that the necessary components are included for execution in the Maude-NPA environment.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 13:21:02 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nunify in FOO : Z =? f(X, Y) /\\ g(Z) =? g(S) .\n\nSolution 1\nZ --> #1:Small\nX --> 1\nY --> #1:Small\nS --> #1:Small\n\nSolution 2\nZ --> #1:Small\nX --> #1:Small\nY --> 1\nS --> #1:Small\n\nSolution 3\nZ --> f(#1:Foo, #2:Foo)\nX --> #1:Foo\nY --> #2:Foo\nS --> #3:Small\n==========================================\nvariant unify in FOO : Z =? f(X, Y) /\\ g(Z) =? g(S)  .\n\nUnifier #1\nrewrites: 0\nZ --> f(%1:Foo, %2:Foo)\nX --> %1:Foo\nY --> %2:Foo\nS --> %3:Small\n\nNo more unifiers.\nrewrites: 0\nBye.Warning: \"identityUnificationMay2020-command\", line 4: bad token run.\nWarning: \"identityUnificationMay2020-command\", line 4: no parse for term.\nWarning: \"identityUnificationMay2020-command\", line 5: bad token initials.\nWarning: \"identityUnificationMay2020-command\", line 5: no parse for term.",
                0.6282095909118652
            ]
        ]
    },
    {
        "file": "MAUDE-1/instantiatedViewInternalNameOctober2022.maude",
        "logic": "---\n\n### Description of the Protocol\n\nThis protocol is designed to test and illustrate a specific bug related to the internal naming conventions of multiply instantiated views in the Maude-NPA (Nondeterministic Protocol Analyzer) environment. The focus is on understanding how parameterized sorts instantiated with certain views can exhibit differences from the same sorts created directly by the Maude parser.\n\n#### Components of the Protocol\n\n1. **Module FOO**:\n   - **Parameterization**: The `FOO` module introduces a parameterized sort `X` of type `STRICT-WEAK-ORDER`.\n   - **Protection**: This module protects a list structure instantiated with sets of the type `Set{STRICT-WEAK-ORDER}{X}`.\n   - **Operation**: It defines an operation `a` that produces a non-empty list (`NeList`) of sets containing elements of the parameterized type. This operation does not take any parameters and is intended to demonstrate the behavior of the list structure in conjunction with the defined parameterized sorts.\n\n2. **Module BAR**:\n   - **Protection**: The `BAR` module similarly protects a list structure but with a different parameterization, specifically using `Set{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{Int<}`.\n   - **Operation**: Similar to the `FOO` module, it defines an operation `a` that also produces a non-empty list of sets. However, this time, the sets are structured to include `STRICT-TOTAL-ORDER` and `Int<`, indicating a stricter ordering condition.\n\n#### Purpose\n\nThe primary goal of these modules is to demonstrate the differences that arise from the use of parameterized sorts and views, specifically concerning how they are interpreted and instantiated within the Maude environment. By comparing the behaviors of `FOO` and `BAR`, one can investigate the discrepancies and potential bugs that may occur when dealing with multiply instantiated views.\n\nThe protocol showcases the importance of correctly handling parameterized sorts and emphasizes the need for careful attention to the instantiation and usage of views in formal specifications.\n\n---\n\n### Corresponding Maude Code\n\nBased on the description, the corresponding Maude code can be run in the Maude-NPA environment as follows:\n\n```maude\nset show advisories off .\n\nfmod FOO{X :: STRICT-WEAK-ORDER} is\n  protecting LIST{Set{STRICT-WEAK-ORDER}{X}} .\n  op a : -> NeList{Set{STRICT-WEAK-ORDER}{X}} .\nendfm\n\nshow kinds .\n\nfmod BAR is\n  protecting LIST{Set{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{Int<}} .\n  op a : -> NeList{Set{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{Int<}} .\nendfm\n\nshow kinds .\n```",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 21:21:45 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n[Bool] (error free):\n\t1\tBool\n\n[X$Elt] (error free):\n\t1\tX$Elt\n\n[NeList{Set{STRICT-WEAK-ORDER}{X}}] (error free):\n\t1\tNeList{Set{STRICT-WEAK-ORDER}{X}}\n[Bool] (error free):\n\t1\tBool\n\n[NeList{Set{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{Int<}}] (error free):\n\t1\tNeList{Set{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{Int<}}\nBye.Warning: \"instantiatedViewInternalNameOctober2022.maude\", line 9 (fmod FOO):\n    syntax error\nWarning: \"instantiatedViewInternalNameOctober2022.maude\", line 10 (fmod FOO):\n    undeclared sort NeList{Set{STRICT-WEAK-ORDER}{X}}.\nWarning: \"instantiatedViewInternalNameOctober2022.maude\", line 16 (fmod BAR):\n    syntax error\nWarning: \"instantiatedViewInternalNameOctober2022.maude\", line 17 (fmod BAR):\n    undeclared sort NeList{Set{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{Int<}}.\nWarning: \"instantiatedViewInternalNameOctober2022-command\", line 4: bad token\n    run.\nWarning: \"instantiatedViewInternalNameOctober2022-command\", line 4: no parse\n    for term.\nWarning: \"instantiatedViewInternalNameOctober2022-command\", line 5: bad token\n    initials.\nWarning: \"instantiatedViewInternalNameOctober2022-command\", line 5: no parse\n    for term.",
                0.5774176120758057
            ]
        ]
    },
    {
        "file": "MAUDE-1/instantiationJuly2019.maude",
        "logic": "### Protocol Description\n\n**Protocol Name**: Custom Protocol\n\n**Overview**: This protocol defines a simple system with two primary modules: `FOO` and `BAR`, alongside an auxiliary module `BAZ`. The `FOO` module introduces a basic sort `Small` and an operation `a`, while the `BAR` module defines a larger sort `Big` that encompasses `Small` and includes an operation `f` that evaluates to a boolean value. The `BAZ` module introduces another sort `Baz` and an operation `b`. A view `V` is defined to map the operation `a` to the operation `b` in the `BAZ` module, allowing for a transformation between the two sorts.\n\n#### Components:\n\n1. **Module FOO**:\n   - **Sorts**:\n     - `Small`: A basic sort representing small entities.\n   - **Operations**:\n     - `a`: An operation that produces an instance of the `Small` sort.\n\n2. **Module BAR**:\n   - **Sorts**:\n     - `Big`: A sort that includes `Small`.\n   - **Subsorts**:\n     - `Small` is a subsort of `Big`.\n   - **Operations**:\n     - `f`: A function that takes a `Big` type and returns a boolean. The function returns `true` when applied to `a`.\n\n3. **Module BAZ**:\n   - **Sorts**:\n     - `Baz`: A sort representing another entity type.\n   - **Operations**:\n     - `b`: An operation that produces an instance of the `Baz` sort.\n\n4. **View V**:\n   - This view establishes a correspondence between the sort `Small` in `FOO` and the sort `Baz` in `BAZ`, specifically mapping the operation `a` to `b`. This allows for the transfer of results from one module to the other.\n\n5. **Module TEST**:\n   - This module imports the `BAR` module specialized by the view `V`, allowing it to use the operations defined in `BAR` with the mappings provided by `V`.\n\n#### Execution:\nThe final command `red b` evaluates the operation `b`, which is defined in the `BAZ` module. This serves as the main execution point of the protocol.\n\n### Corresponding Maude File:\n\nBased on the above description, the Maude file that can be run in Maude-NPA would remain largely the same as the one provided, as it already captures the essence of the protocol. However, if we were to outline it based on the description:\n\n```maude\nset show timing off .\nset show advisories off .\n\nfth FOO is\n  sort Small .\n  op a : -> Small .\nendfth\n\nfmod BAR{X :: FOO} is\n  sort Big .\n  subsort X$Small < Big .\n  op f : Big -> Bool .\n  eq f(a) = true .\nendfm\n\nfmod BAZ is\n  sort Baz .\n  op b : -> Baz .\nendfm\n\nview V from FOO to BAZ is\n  sort Small to Baz .\n  op a to b .\nendv\n\nfmod TEST is\n  inc BAR{V} .\nendfm\n\nred b .\n```",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 21:00:10 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in TEST : b .\nrewrites: 0\nresult Baz: b\nBye.Warning: \"instantiationJuly2019-command\", line 4: bad token run.\nWarning: \"instantiationJuly2019-command\", line 4: no parse for term.\nWarning: \"instantiationJuly2019-command\", line 5: bad token initials.\nWarning: \"instantiationJuly2019-command\", line 5: no parse for term.",
                0.6280701160430908
            ]
        ]
    },
    {
        "file": "MAUDE-1/initialEqualityPredicate.maude",
        "logic": "### Protocol Description\n\n1. **Module DECOMPOSE**:\n   - This module defines a set of natural numbers (`Nat`) and strings (`String`). It includes constructors for various operations such as `f`, `g`, `h`, `i`, `c`, and `b`.\n   - The operations are defined as follows:\n     - `0`: a constant representing zero.\n     - `f` and `g`: binary operations that combine two `Nat` values into another `Nat`.\n     - `h` and `i`: combine two `Nat` values into a `String`.\n     - `c`: a commutative operation that combines two `Nat` values.\n     - `b`: an associative and commutative operation with an identity element (`0`).\n     - `s`: an iterative constructor for `Nat`.\n   - The module also includes several reduction rules:\n     - **Free Rules**: Basic properties of the operations, including idempotency and commutativity.\n     - **Dissimilar Collapse Symbol**: Represents the case where two arguments are treated as distinct.\n     - **Iterative Reductions**: Properties of the iterative operation `s` for large inputs.\n     - **Commutative Properties**: Rules showing how the operation `c` behaves with respect to its arguments.\n     - **Compound Properties**: Relationships between combinations of `f` and `g`.\n\n2. **Module FOO**:\n   - This module defines a new sort called `Foo`, with operations such as `a`, `b`, `c`, and `1`, which are used to create elements of this sort.\n   - The operations defined include:\n     - `__`: an associative operation on `Foo`.\n     - `_+_`: an associative and commutative operation on `Foo`.\n     - `s`: a commutative operation on `Foo`.\n     - `f`: an associative and commutative operation with an identity element.\n     - `g`, `h`, `p`: operations that manipulate elements of `Foo`.\n   - The module includes reduction rules that explain how equations involving `Foo` are simplified:\n     - **Ground vs Equationally-Stable**: Showing stability under certain transformations.\n     - **Canceling Under Commutative Operations**: Properties of the operation `s` when combined with `g`.\n     - **Associative and Commutative Properties**: Demonstrating how combinations of `g` and `h` behave when reduced.\n\n### Generating the Corresponding Maude File\n\nBased on the above description, you can create a new Maude file that reflects the same operational and algebraic properties. Here is a template for a corresponding Maude file based on the description provided:\n\n```maude\nset show timing off .\nset show advisories off .\n\nfmod PROTOCOL is\n  inc INITIAL-EQUALITY-PREDICATE .\n  sorts Nat String Foo .\n  op 0 : -> Nat .\n  ops f g : Nat Nat -> Nat [ctor] .\n  ops h i : Nat Nat -> String [ctor] .\n  op c : Nat Nat -> Nat [ctor comm] .\n  ops b : Nat Nat -> Nat [assoc comm id: 0] .\n  op s : Nat -> Nat [iter ctor] .\n\n  op __ : Foo Foo -> Foo [assoc] .\n  op _+_ : Foo Foo -> Foo [assoc comm] .\n  op s : Foo Foo -> Foo [comm] .\n  op f : Foo Foo -> Foo [assoc comm id: 1] .\n  ops g h p : Foo -> Foo .\n\n  vars W X Y Z : Nat .\n  vars A B C D : Nat .\n  var E : Foo .\n\n  eq p(X) = g(h(X)) .\n  red X .=. X .\n  red X .=. Y .\n  red f(X, Y) .=. f(Y, Z) .\n  red f(X, Y) .=. f(Y, X) .\n  red f(X, Y) .=. X .\n  red f(f(X, Y), Z) .=. f(X, Y) .\n  red f(X, Y) .=. g(W, Z) .\n  red h(X, Y) .=. h(W, Z) .\n  red h(X, Y) .=. h(Y, X) .\n  red h(X, Y) .=. i(W, Z) .\n  red f(X, Y) .=. b(W, Z) .\n  red s^100(X) .=. s^40(X) .\n  red s^100(X) .=. s^40(Y) .\n  red s^10(X) .=. s^10(Y) .\n  red c(X, Y) .=. c(A, B) .\n  red c(X, Y) .=. c(A, X) .\n  red c(c(X, Y), Z) .=. c(X, Y) .\n  red g(X) .=. g(Y) .\n  red f(a, g(b), c) .=. h(X) .\n  red s(g(X), Z) .=. s(Y, g(X)) .\n  red g(A) + g(B) + g(C) .=. g(A) + B + h(C) .\n  red g(A) + g(B) + g(C) .=. g(A) + B .\n  red g(A) (B) X h(A) Y h(C) .=. h(A) g(D) g(E) Z X h(A) .\n  red g(A) X Y h(A) h(C) .=. g(D) g(E) g(D) X h(A) .\n  red g(A) g(B) X h(A) Y h(C) .=. g(D) g(E) Z X h(A) .\n\nendfm\n```",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 00:08:28 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"initialEqualityPredicate.maude\", line 5 (fmod DECOMPOSE): module\n    INITIAL-EQUALITY-PREDICATE does not exist.\nWarning: \"initialEqualityPredicate.maude\", line 17: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 17: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 18: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 18: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 21: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 21: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 22: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 22: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 23: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 23: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 24: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 24: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 25: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 25: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 26: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 26: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 27: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 27: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 28: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 28: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 31: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 31: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 34: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 34: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 35: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 35: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 36: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 36: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 39: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 39: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 40: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 40: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 41: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 41: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 44: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 44: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 45: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 45: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 49 (fmod FOO): module\n    INITIAL-EQUALITY-PREDICATE does not exist.\nWarning: \"initialEqualityPredicate.maude\", line 62: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 62: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 65: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 65: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 68: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 68: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 71: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 71: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 72: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 72: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 75: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 75: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 76: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 76: no parse for term.\nWarning: \"initialEqualityPredicate.maude\", line 77: bad token .=..\nWarning: \"initialEqualityPredicate.maude\", line 77: no parse for term.\nWarning: \"initialEqualityPredicate-command\", line 4: bad token run.\nWarning: \"initialEqualityPredicate-command\", line 4: no parse for term.\nWarning: \"initialEqualityPredicate-command\", line 5: bad token initials.\nWarning: \"initialEqualityPredicate-command\", line 5: no parse for term.",
                0.6795992851257324
            ]
        ]
    },
    {
        "file": "MAUDE-1/irredUnifyFeb2021.maude",
        "logic": "Based on the provided Maude file, the protocol can be described as follows:\n\n---\n\n### Protocol Description: Irredundant Unification in Associative Lists\n\n#### Overview\nThis protocol is designed to test a specific bug related to irredundant unification within the Maude-NPA (Nondeterministic Protocol Analyzer). The issue arises when destructive updating of unifiers occurs, particularly when these unifiers share the same structure but differ in sorts. This situation can lead to corruption within the unification filter, resulting in the loss of irredundant unifiers due to spurious subsumptions. \n\n#### Definitions\nThe protocol employs a modular approach using the Maude functional module `ASSOC-LIST`, which defines various sorts and operations relevant to associative lists. \n\n#### Sorts\n- **Elt**: Represents individual elements.\n- **Pair**: A pair of elements.\n- **Triple**: A triple of elements.\n- **List**: A collection of elements, pairs, or triples.\n\n#### Subsorts\n- `Pair` and `Triple` are defined as subsorts of `List`, indicating that they can be treated as lists within this context.\n\n#### Operations\n1. **Associative Operations**:\n   - `__ : List List -> List`: An associative operation that combines two lists.\n   - `__ : Elt Elt -> Pair`: An associative operation that combines two elements into a pair.\n   - `__ : Elt Pair -> Triple`: An associative operation that combines an element and a pair into a triple.\n   - `__ : Pair Elt -> Triple`: An associative operation that combines a pair and an element into a triple.\n\n2. **Reversal**:\n   - `rev : List -> List`: An operation that reverses a given list.\n\n#### Variables\n- Lists: `A`, `B`, `C`, `X`, `Y`, `Z`\n- Pairs: `P`, `Q`, `R`\n- Elements: `E`, `F`, `G`\n- Triples: `S`, `T`, `U`, `V`\n\n#### Unification Tests\n- The protocol includes tests for unification and irredundant unification of two triples `S` and `T`, with the resulting unifiers being captured in variables `A` and `B`. \n- The expressions `unify S T =? A B` and `irred unify S T =? A B` are used to probe the unification mechanism and check for issues related to irredundancy.\n\n#### Purpose\nThe primary goal of this protocol is to investigate and demonstrate the bug related to the unification process in the context of associative lists and to ensure that the implementation correctly handles the cases of destructive updating without losing irredundant unifiers.\n\n---\n\nThis structured description can be used as a reference for generating a corresponding Maude file that can be run by Maude-NPA, ensuring that all necessary components and operations are represented correctly in the code.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 21:22:00 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nunify in ASSOC-LIST : S T =? A B .\n==========================================\nunify in ASSOC-LIST : S T =? A B .\nBye.Warning: Term S T is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"irredUnifyFeb2021.maude\", line 27: skipped unexpected token: irred\nWarning: Term S T is non-ground and unification for its top symbol is not\n    currently supported.\nWarning: \"irredUnifyFeb2021-command\", line 4: bad token run.\nWarning: \"irredUnifyFeb2021-command\", line 4: no parse for term.\nWarning: \"irredUnifyFeb2021-command\", line 5: bad token initials.\nWarning: \"irredUnifyFeb2021-command\", line 5: no parse for term.",
                0.6788480281829834
            ]
        ]
    },
    {
        "file": "MAUDE-1/kindNameDecember2022.maude",
        "logic": "### Protocol Description\n\n#### Overview\nThe protocol defined in the Maude file is a simple module named `FOO`. It is designed to demonstrate a scenario in which elements of two different sorts, `S{X}` and `T{X}`, interact through a function. The module highlights the use of parameterized sorts and the definition of operations on these sorts.\n\n#### Key Components\n\n1. **Parameterization**: \n   - The module `FOO` is parameterized by a sort `X`, which is declared to be of type `TRIV`. This means that `X` can represent any element of the trivial sort. \n\n2. **Sorts**: \n   - Two new sorts are defined: `S{X}` and `T{X}`. These sorts are dependent on the parameter `X` and represent different types of structured data within the protocol.\n\n3. **Subsort Relationships**: \n   - The module establishes a subsort relationship where both `S{X}` and `T{X}` are considered subtypes of `X$Elt`. This implies that any element of `S{X}` or `T{X}` can be treated as an element of the more general sort `X$Elt`.\n\n4. **Operation Definition**: \n   - The operation `f` is defined to take an input of the type `[S{X}, T{X}]` and produce an output of the same type `[S{X}, T{X}]`. This operation represents a transformation or interaction between the elements of sorts `S{X}` and `T{X}`.\n\n#### Purpose\nThe main objective of this protocol is to test the functionality of the Maude-NPA tool, specifically focusing on the handling of parameterized sorts and the correct printing of kinds from premodules. It serves as a basic foundation for more complex interactions and can be expanded for further experimentation with the Maude language.\n\n### Conclusion\nThe `FOO` module serves as a minimal example of how to define sorts, subsorts, and operations in Maude, while also providing a basis for testing and debugging purposes related to kind printing. \n\n### Example Maude File Structure\nBased on the above description, the corresponding Maude file can be structured as follows:\n\n```maude\nset show advisories off .\n\n*** Test for bug where kinds were printed incorrectly from premodules. ***\n\nfmod FOO{X :: TRIV} is\n  sorts S{X} T{X} .\n  subsort X$Elt < S{X} T{X} .\n  op f : [S{X},T{X}] -> [S{X},T{X}] .\nendfm\n\nshow mod .\n```",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 13:21:30 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nfmod FOO{X :: TRIV} is\n  sorts S{X} T{X} .\n  subsorts X$Elt < S{X} T{X} .\n  op f : [S`{X`},T{X}] -> [S`{X`},T{X}] .\nendfm\nBye.Warning: \"kindNameDecember2022-command\", line 4: bad token run.\nWarning: \"kindNameDecember2022-command\", line 4: no parse for term.\nWarning: \"kindNameDecember2022-command\", line 5: bad token initials.\nWarning: \"kindNameDecember2022-command\", line 5: no parse for term.",
                0.6289768218994141
            ]
        ]
    },
    {
        "file": "MAUDE-1/lattice.maude",
        "logic": "### Description of the Lattice Protocol\n\n**Lattice Overview:**\nThis protocol defines a mathematical structure known as a lattice, which is a partially ordered set in which any two elements have a unique supremum (least upper bound) and an infimum (greatest lower bound). The lattice is represented by the sort `Lat`, which includes two distinguished elements: the bottom element (denoted as `0`) and the top element (denoted as `1`).\n\n**Operations:**\n- **Supremum (`\\/`)**: This operation takes two lattice elements and produces their least upper bound.\n- **Infimum (`/\\`)**: This operation takes two lattice elements and produces their greatest lower bound.\n- **Complement (`c`)**: This operation provides the complement of a lattice element.\n\n**Key Properties of the Lattice:**\n1. **Idempotency**:\n   - The supremum and infimum operations are idempotent:\n     - \\( X \\\\/ X = X \\) (LAT-01)\n     - \\( X \\\\/ X = X \\) (LAT-02)\n\n2. **Identity Elements**:\n   - The bottom element acts as the identity for supremum:\n     - \\( X \\\\/ 0 = X \\) (LAT-05)\n   - The top element acts as the identity for infimum:\n     - \\( X \\\\/ 1 = X \\) (LAT-06)\n\n3. **Absorption Laws**:\n   - These laws relate the supremum and infimum operations:\n     - \\( 1 \\\\/ X = 1 \\) (LAT-07)\n     - \\( 0 \\\\ X = 0 \\) (LAT-08)\n     - \\( X \\\\ (X \\\\/ Y) = X \\) (LAT-09)\n     - \\( X \\\\/ (X \\\\ Y) = X \\) (LAT-10)\n\n4. **Modular Lattice Axiom**:\n   - The modular property provides a specific relationship between the operations:\n     - If \\( (X \\\\ Z) = X \\), then \\( Z \\\\ (X \\\\/ Y) = X \\\\/ (Y \\\\ Z) \\) (LAT-13).\n\n5. **Complement Axioms**:\n   - These axioms define the behavior of complements with respect to the lattice elements:\n     - \\( X \\\\/ c(X) = 1 \\) (LAT-14)\n     - \\( X \\\\ c(X) = 0 \\) (LAT-15)\n\n6. **Extensions of Properties**:\n   - Several properties are extended to combinations of elements and their complements:\n     - \\( Z \\\\ X \\\\ (X \\\\/ Y) = Z \\\\ X \\) (LAT-11)\n     - \\( Z \\\\/ X \\\\/ (X \\\\ Y) = Z \\\\/ X \\) (LAT-12)\n     - \\( c(0) = 1 \\) (LAT-18)\n     - \\( c(1) = 0 \\) (LAT-19)\n     - \\( c(X \\\\ Y) \\\\/ X = 1 \\) (LAT-20)\n     - \\( c(X \\\\/ Y) \\\\ X = 0 \\) (LAT-21)\n\n### Summary\nThis Maude file represents a formal definition of a lattice structure with specific operations and axioms that govern its behavior. It captures the essential properties of lattices, including idempotency, absorption, modularity, and the existence of complements. The implementation in Maude allows for rigorous reasoning about these properties and can be used to prove various theorems related to lattice theory.\n\n### Generating a Corresponding Maude File\nTo create a runnable Maude file based on this description, you can use the provided Maude code directly, as it already encapsulates the definitions and rules necessary to represent the lattice structure as described. You may save the text in a `.maude` file and run it using the Maude-NPA tool for further analysis or verification of lattice properties.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 21:21:57 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"lattice-command\", line 4: bad token run.\nWarning: \"lattice-command\", line 4: no parse for term.\nWarning: \"lattice-command\", line 5: bad token initials.\nWarning: \"lattice-command\", line 5: no parse for term.",
                0.6296980381011963
            ]
        ]
    },
    {
        "file": "MAUDE-1/legacyMetaGetVariant.maude",
        "logic": "### Protocol Description\n\nThe protocol defined in the Maude file consists of a module named `XOR` that implements an algebraic structure for the XOR operation, along with a testing module `TEST` that incorporates the `XOR` module and includes meta-level definitions.\n\n#### XOR Module\n\n1. **Types and Sorts**:\n   - The `XOR` module defines a sort `XOR` which is a subtype of `Elem`.\n   - It also defines a sort `Elem`, which acts as a base sort for elements in the algebra.\n\n2. **Constants**:\n   - Four constants, `cst1`, `cst2`, `cst3`, and `cst4`, are declared as elements of the `Elem` sort.\n\n3. **Operations**:\n   - The module defines the following operations:\n     - `_+_`: A binary operation on `XOR` that is associative and commutative.\n     - `0`: A constant representing the identity element for the addition operation.\n     - `a`: A constant representing another element in the `XOR` structure.\n\n4. **Equations**:\n   - The module includes several equations that define the behavior of the XOR operation:\n     - `Y + 0 = Y`: The identity property of addition.\n     - `X + X = 0`: The property that an element XORed with itself results in the identity element (zero).\n     - `X + X + Y = Y`: This property reflects the commutative nature of the XOR operation.\n\n#### TEST Module\n\nThe `TEST` module includes the following features:\n- It imports the `XOR` module to utilize its definitions and operations.\n- It also incorporates `META-LEVEL`, which likely provides additional meta-level operations or definitions for testing purposes.\n\n#### Reductions\n\nThe file contains several `red` commands that perform reductions using `metaGetVariant`:\n- The `metaGetVariant` function is invoked with different parameters to explore the variants of terms formed by the XOR operation combined with constants and variables.\n- The variations tested include terms like `X:XOR + cst1` and `X:XOR + cst2`, which demonstrate the use of constants in combination with variables.\n\n### Summary\n\nIn summary, the protocol defines an algebraic structure for XOR operations using a Maude module. It specifies the basic properties of XOR, including its commutative and associative nature, as well as its identity and cancellation properties. The testing module allows for the examination of various combinations of XOR expressions, making it suitable for further analysis or verification in cryptographic protocols or similar applications.\n\n### Generating the Corresponding Maude File\n\nTo run this protocol in Maude-NPA, the content of the Maude file provided initially can be used as is. The description above can serve as documentation to understand the structure and behavior of the protocol, allowing users to modify or extend it as needed for their specific applications.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Thu May 22 10:24:36 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in TEST : metaGetVariant(['XOR], upTerm(cst1 + X:XOR), empty, 0, 0) .\nrewrites: 3\nresult Variant: {'_+_['cst1.Elem,'#1:XOR],\n\t'X:XOR <- '#1:XOR,1}\n==========================================\nreduce in TEST : metaGetVariant(upModule('XOR, false), upTerm(cst1 + X:XOR),\n    empty, 0, 0) .\nrewrites: 3\nresult Variant: {'_+_['cst1.Elem,'#1:XOR],\n\t'X:XOR <- '#1:XOR,1}\n==========================================\nreduce in TEST : metaGetVariant(['XOR], upTerm(cst1 + X:XOR), empty, 10, 0) .\nrewrites: 3\nresult Variant: {'_+_['cst1.Elem,'#11:XOR],\n\t'X:XOR <- '#11:XOR,11}\n==========================================\nreduce in TEST : metaGetVariant(['XOR], upTerm(cst1 + X:XOR), empty, 0, 1) .\nrewrites: 6\nresult Variant: {'cst1.Elem,\n\t'X:XOR <- '0.XOR,(0).Zero}\n==========================================\nreduce in TEST : metaGetVariant(['XOR], upTerm(cst1 + X:XOR), empty, 0, 2) .\nrewrites: 3\nresult Variant: {'0.XOR,\n\t'X:XOR <- 'cst1.Elem,(0).Zero}\n==========================================\nreduce in TEST : metaGetVariant(['XOR], upTerm(cst1 + X:XOR), empty, 0, 3) .\nrewrites: 3\nresult Variant: {'%1:XOR,\n\t'X:XOR <- '_+_['cst1.Elem,'%1:XOR],1}\n==========================================\nreduce in TEST : metaGetVariant(['XOR], upTerm(cst1 + X:XOR), empty, 0, 4) .\nrewrites: 3\nresult Variant?: noVariant\n==========================================\nreduce in TEST : metaGetVariant(['XOR], upTerm(cst2 + X:XOR), upTerm(a +\n    X:XOR), 0, 0) .\nrewrites: 4\nresult Variant: {'_+_['cst2.Elem,'#1:XOR],\n\t'X:XOR <- '#1:XOR,1}\n==========================================\nreduce in TEST : metaGetVariant(['XOR], upTerm(cst2 + X:XOR), upTerm(a +\n    X:XOR), 0, 1) .\nrewrites: 6\nresult Variant: {'0.XOR,\n\t'X:XOR <- 'cst2.Elem,(0).Zero}\n==========================================\nreduce in TEST : metaGetVariant(['XOR], upTerm(cst2 + X:XOR), upTerm(a +\n    X:XOR), 0, 2) .\nrewrites: 4\nresult Variant: {'%1:XOR,\n\t'X:XOR <- '_+_['cst2.Elem,'%1:XOR],1}\n==========================================\nreduce in TEST : metaGetVariant(['XOR], upTerm(cst2 + X:XOR), upTerm(a +\n    X:XOR), 0, 3) .\nrewrites: 4\nresult Variant?: noVariant\nBye.Warning: \"legacyMetaGetVariant-command\", line 4: bad token run.\nWarning: \"legacyMetaGetVariant-command\", line 4: no parse for term.\nWarning: \"legacyMetaGetVariant-command\", line 5: bad token initials.\nWarning: \"legacyMetaGetVariant-command\", line 5: no parse for term.",
                0.6805930137634277
            ]
        ]
    },
    {
        "file": "MAUDE-1/mapToParameterTheory.maude",
        "logic": "### Description of the Protocol\n\nThis protocol explores various mappings of sorts and operators across different modules using views in Maude. Each section of the code addresses a different scenario of mapping:\n\n1. **Explicit-Explicit Sort Mapping**: This section shows how a sort from a theory can be explicitly mapped to a sort in a parameterized module using a view. The example demonstrates how an operator in one module can be transformed based on the sort mapping defined in the view.\n\n2. **Implicit-Explicit Sort Mapping**: This case illustrates how an implicit mapping from a sort in a theory to a sort in a parameterized module can affect operator types. It shows how the operator's input can change based on the view's implicit and explicit mappings.\n\n3. **Explicit-Implicit Sort Mapping**: This section highlights how an explicit sort mapping can coexist with an implicit mapping in another view. The resulting operator type is adjusted accordingly based on the sort mappings.\n\n4. **Implicit-Implicit Sort Mapping**: Similar to the previous sections, this case emphasizes both implicit mappings, which can lead to changes in how operators are defined and utilized.\n\n5. **Explicit-Explicit Operator Mapping**: This part demonstrates how both sorts and operators can be explicitly mapped. The interactions between the operators' definitions across views and how they are instantiated in the final module is explored.\n\n6. **Implicit-Explicit Operator Mapping**: In this section, one operator is explicitly mapped while another remains implicit. The consequences of this combination are analyzed through the operator definitions.\n\n7. **Operator Mapping Variants**: Several variations of operator mappings are presented, including:\n   - **op->term-explicit and explicit-op->term operator mappings**, where the transformation of operators to terms changes based on the mappings defined in views.\n   - **Mapping with lost variables**: Cases where certain variables in equations are lost during the mapping process, demonstrating the complexity and subtlety of operator transformations across modules.\n   - **Polymorphic operator mapping**: This final section shows how polymorphic operators can be mapped across modules while retaining their type properties.\n\n### Corresponding Maude File\n\n```maude\nset show timing off .\n\nset include BOOL off .\n\n**************************************\n*** explicit-explicit sort mapping ***\n**************************************\n\nfth T is\n  sort Elt .\nendfth\n\nfth T2 is\n  sort Elt2 .\nendfth\n\nfmod M{X :: T} is\n  sort Foo{X} .\n  op f : X$Elt -> Foo{X} .\nendfm\n\nview V{A :: T} from T2 to M{A} is\n  sort Elt2 to A$Elt .\nendv\n\nfmod C is\n  sort Bar .\n  op a : -> Bar .\nendfm\n\nview V2 from T to C is\n  sort Elt to Bar .\nendv\n\nfmod M2{Y :: T2} is\n  sort Baz{Y} .\n  op g : Y$Elt2 -> Baz{Y} .\nendfm\n\nfmod TEST is\n  inc M2{V{V2}} .\nendfm\n\nshow all .\n\n*** Continue with implicit-explicit, explicit-implicit, and other cases similarly as above.\n\n```",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 13:20:47 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nfmod TEST is\nendfm\nfmod TEST is\nendfm\nfmod TEST is\nendfm\nfmod TEST is\nendfm\nfmod TEST is\nendfm\nfmod TEST is\nendfm\nfmod TEST is\nendfm\nfmod TEST is\nendfm\nfmod TEST is\nendfm\nfmod TEST is\nendfm\nfmod TEST is\nendfm\nBye.Warning: \"mapToParameterTheory.maude\", line 29: syntax error\nWarning: \"mapToParameterTheory.maude\", line 29: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 29: skipped unexpected token: ::\nWarning: \"mapToParameterTheory.maude\", line 29: skipped unexpected token: T\nWarning: \"mapToParameterTheory.maude\", line 29: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 29: skipped unexpected token: from\nWarning: \"mapToParameterTheory.maude\", line 29: skipped unexpected token: T2\nWarning: \"mapToParameterTheory.maude\", line 29: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 29: skipped unexpected token: M\nWarning: \"mapToParameterTheory.maude\", line 29: skipped unexpected token: {\nWarning: \"mapToParameterTheory.maude\", line 29: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 29: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 29: skipped unexpected token: is\nWarning: \"mapToParameterTheory.maude\", line 30: skipped unexpected token: Elt2\nWarning: \"mapToParameterTheory.maude\", line 30: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 30: skipped unexpected token: A$Elt\nWarning: \"mapToParameterTheory.maude\", line 31: skipped unexpected token: endv\nWarning: \"mapToParameterTheory.maude\", line 48 (fmod TEST): syntax error\nWarning: \"mapToParameterTheory.maude\", line 77: syntax error\nWarning: \"mapToParameterTheory.maude\", line 77: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 77: skipped unexpected token: ::\nWarning: \"mapToParameterTheory.maude\", line 77: skipped unexpected token: T\nWarning: \"mapToParameterTheory.maude\", line 77: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 77: skipped unexpected token: from\nWarning: \"mapToParameterTheory.maude\", line 77: skipped unexpected token: T2\nWarning: \"mapToParameterTheory.maude\", line 77: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 77: skipped unexpected token: M\nWarning: \"mapToParameterTheory.maude\", line 77: skipped unexpected token: {\nWarning: \"mapToParameterTheory.maude\", line 77: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 77: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 77: skipped unexpected token: is\nWarning: \"mapToParameterTheory.maude\", line 79: skipped unexpected token: endv\nWarning: \"mapToParameterTheory.maude\", line 81: skipped unexpected token: C\nWarning: \"mapToParameterTheory.maude\", line 81: skipped unexpected token: is\nWarning: \"mapToParameterTheory.maude\", line 82: skipped unexpected token: Bar\nWarning: \"mapToParameterTheory.maude\", line 83: syntax error\nWarning: \"mapToParameterTheory.maude\", line 83: skipped unexpected token: a\nWarning: \"mapToParameterTheory.maude\", line 83: skipped unexpected token: :\nWarning: \"mapToParameterTheory.maude\", line 83: skipped unexpected token: ->\nWarning: \"mapToParameterTheory.maude\", line 83: skipped unexpected token: Bar\nWarning: \"mapToParameterTheory.maude\", line 84: skipped unexpected token: endfm\nWarning: \"mapToParameterTheory.maude\", line 96 (fmod TEST): syntax error\nWarning: \"mapToParameterTheory.maude\", line 125: syntax error\nWarning: \"mapToParameterTheory.maude\", line 125: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 125: skipped unexpected token: ::\nWarning: \"mapToParameterTheory.maude\", line 125: skipped unexpected token: T\nWarning: \"mapToParameterTheory.maude\", line 125: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 125: skipped unexpected token: from\nWarning: \"mapToParameterTheory.maude\", line 125: skipped unexpected token: T2\nWarning: \"mapToParameterTheory.maude\", line 125: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 125: skipped unexpected token: M\nWarning: \"mapToParameterTheory.maude\", line 125: skipped unexpected token: {\nWarning: \"mapToParameterTheory.maude\", line 125: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 125: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 125: skipped unexpected token: is\nWarning: \"mapToParameterTheory.maude\", line 126: skipped unexpected token: Elt2\nWarning: \"mapToParameterTheory.maude\", line 126: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 126: skipped unexpected token:\n    A$Elt\nWarning: \"mapToParameterTheory.maude\", line 127: skipped unexpected token: endv\nWarning: \"mapToParameterTheory.maude\", line 144 (fmod TEST): syntax error\nWarning: \"mapToParameterTheory.maude\", line 173: syntax error\nWarning: \"mapToParameterTheory.maude\", line 173: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 173: skipped unexpected token: ::\nWarning: \"mapToParameterTheory.maude\", line 173: skipped unexpected token: T\nWarning: \"mapToParameterTheory.maude\", line 173: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 173: skipped unexpected token: from\nWarning: \"mapToParameterTheory.maude\", line 173: skipped unexpected token: T2\nWarning: \"mapToParameterTheory.maude\", line 173: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 173: skipped unexpected token: M\nWarning: \"mapToParameterTheory.maude\", line 173: skipped unexpected token: {\nWarning: \"mapToParameterTheory.maude\", line 173: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 173: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 173: skipped unexpected token: is\nWarning: \"mapToParameterTheory.maude\", line 175: skipped unexpected token: endv\nWarning: \"mapToParameterTheory.maude\", line 177: skipped unexpected token: C\nWarning: \"mapToParameterTheory.maude\", line 177: skipped unexpected token: is\nWarning: \"mapToParameterTheory.maude\", line 178: skipped unexpected token: Elt\nWarning: \"mapToParameterTheory.maude\", line 179: syntax error\nWarning: \"mapToParameterTheory.maude\", line 179: skipped unexpected token: a\nWarning: \"mapToParameterTheory.maude\", line 179: skipped unexpected token: :\nWarning: \"mapToParameterTheory.maude\", line 179: skipped unexpected token: ->\nWarning: \"mapToParameterTheory.maude\", line 179: skipped unexpected token: Elt\nWarning: \"mapToParameterTheory.maude\", line 180: skipped unexpected token:\n    endfm\nWarning: \"mapToParameterTheory.maude\", line 192 (fmod TEST): syntax error\nWarning: \"mapToParameterTheory.maude\", line 224: syntax error\nWarning: \"mapToParameterTheory.maude\", line 224: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 224: skipped unexpected token: ::\nWarning: \"mapToParameterTheory.maude\", line 224: skipped unexpected token: T\nWarning: \"mapToParameterTheory.maude\", line 224: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 224: skipped unexpected token: from\nWarning: \"mapToParameterTheory.maude\", line 224: skipped unexpected token: T2\nWarning: \"mapToParameterTheory.maude\", line 224: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 224: skipped unexpected token: M\nWarning: \"mapToParameterTheory.maude\", line 224: skipped unexpected token: {\nWarning: \"mapToParameterTheory.maude\", line 224: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 224: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 224: skipped unexpected token: is\nWarning: \"mapToParameterTheory.maude\", line 225: skipped unexpected token: Elt2\nWarning: \"mapToParameterTheory.maude\", line 225: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 225: skipped unexpected token:\n    A$Elt\nWarning: \"mapToParameterTheory.maude\", line 226: syntax error\nWarning: \"mapToParameterTheory.maude\", line 226: skipped unexpected token: sum\nWarning: \"mapToParameterTheory.maude\", line 226: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 226: skipped unexpected token: _+_\nWarning: \"mapToParameterTheory.maude\", line 227: skipped unexpected token: endv\nWarning: \"mapToParameterTheory.maude\", line 246 (fmod TEST): syntax error\nWarning: \"mapToParameterTheory.maude\", line 276: syntax error\nWarning: \"mapToParameterTheory.maude\", line 276: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 276: skipped unexpected token: ::\nWarning: \"mapToParameterTheory.maude\", line 276: skipped unexpected token: T\nWarning: \"mapToParameterTheory.maude\", line 276: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 276: skipped unexpected token: from\nWarning: \"mapToParameterTheory.maude\", line 276: skipped unexpected token: T2\nWarning: \"mapToParameterTheory.maude\", line 276: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 276: skipped unexpected token: M\nWarning: \"mapToParameterTheory.maude\", line 276: skipped unexpected token: {\nWarning: \"mapToParameterTheory.maude\", line 276: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 276: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 276: skipped unexpected token: is\nWarning: \"mapToParameterTheory.maude\", line 277: skipped unexpected token: Elt2\nWarning: \"mapToParameterTheory.maude\", line 277: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 277: skipped unexpected token:\n    A$Elt\nWarning: \"mapToParameterTheory.maude\", line 279: skipped unexpected token: endv\nWarning: \"mapToParameterTheory.maude\", line 298 (fmod TEST): syntax error\nWarning: \"mapToParameterTheory.maude\", line 328: syntax error\nWarning: \"mapToParameterTheory.maude\", line 328: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 328: skipped unexpected token: ::\nWarning: \"mapToParameterTheory.maude\", line 328: skipped unexpected token: T\nWarning: \"mapToParameterTheory.maude\", line 328: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 328: skipped unexpected token: from\nWarning: \"mapToParameterTheory.maude\", line 328: skipped unexpected token: T2\nWarning: \"mapToParameterTheory.maude\", line 328: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 328: skipped unexpected token: M\nWarning: \"mapToParameterTheory.maude\", line 328: skipped unexpected token: {\nWarning: \"mapToParameterTheory.maude\", line 328: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 328: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 328: skipped unexpected token: is\nWarning: \"mapToParameterTheory.maude\", line 329: skipped unexpected token: Elt2\nWarning: \"mapToParameterTheory.maude\", line 329: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 329: skipped unexpected token:\n    A$Elt\nWarning: \"mapToParameterTheory.maude\", line 330: syntax error\nWarning: \"mapToParameterTheory.maude\", line 330: skipped unexpected token: X\nWarning: \"mapToParameterTheory.maude\", line 330: skipped unexpected token: Y\nWarning: \"mapToParameterTheory.maude\", line 330: skipped unexpected token: :\nWarning: \"mapToParameterTheory.maude\", line 330: skipped unexpected token: Elt2\nWarning: \"mapToParameterTheory.maude\", line 331: syntax error\nWarning: \"mapToParameterTheory.maude\", line 331: skipped unexpected token: sum\nWarning: \"mapToParameterTheory.maude\", line 331: skipped unexpected token: X\nWarning: \"mapToParameterTheory.maude\", line 331: skipped unexpected token: ,\nWarning: \"mapToParameterTheory.maude\", line 331: skipped unexpected token: Y\nWarning: \"mapToParameterTheory.maude\", line 331: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 331: skipped unexpected token: term\nWarning: \"mapToParameterTheory.maude\", line 331: skipped unexpected token: X\nWarning: \"mapToParameterTheory.maude\", line 331: skipped unexpected token: +\nWarning: \"mapToParameterTheory.maude\", line 331: skipped unexpected token: g\nWarning: \"mapToParameterTheory.maude\", line 331: skipped unexpected token: Y\nWarning: \"mapToParameterTheory.maude\", line 332: skipped unexpected token: endv\nWarning: \"mapToParameterTheory.maude\", line 351 (fmod TEST): syntax error\nWarning: \"mapToParameterTheory.maude\", line 381: syntax error\nWarning: \"mapToParameterTheory.maude\", line 381: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 381: skipped unexpected token: ::\nWarning: \"mapToParameterTheory.maude\", line 381: skipped unexpected token: T\nWarning: \"mapToParameterTheory.maude\", line 381: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 381: skipped unexpected token: from\nWarning: \"mapToParameterTheory.maude\", line 381: skipped unexpected token: T2\nWarning: \"mapToParameterTheory.maude\", line 381: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 381: skipped unexpected token: M\nWarning: \"mapToParameterTheory.maude\", line 381: skipped unexpected token: {\nWarning: \"mapToParameterTheory.maude\", line 381: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 381: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 381: skipped unexpected token: is\nWarning: \"mapToParameterTheory.maude\", line 382: skipped unexpected token: Elt2\nWarning: \"mapToParameterTheory.maude\", line 382: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 382: skipped unexpected token:\n    A$Elt\nWarning: \"mapToParameterTheory.maude\", line 383: syntax error\nWarning: \"mapToParameterTheory.maude\", line 383: skipped unexpected token: sum\nWarning: \"mapToParameterTheory.maude\", line 383: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 383: skipped unexpected token: _+_\nWarning: \"mapToParameterTheory.maude\", line 384: skipped unexpected token: endv\nWarning: \"mapToParameterTheory.maude\", line 405 (fmod TEST): syntax error\nWarning: \"mapToParameterTheory.maude\", line 436: syntax error\nWarning: \"mapToParameterTheory.maude\", line 436: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 436: skipped unexpected token: ::\nWarning: \"mapToParameterTheory.maude\", line 436: skipped unexpected token: T\nWarning: \"mapToParameterTheory.maude\", line 436: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 436: skipped unexpected token: from\nWarning: \"mapToParameterTheory.maude\", line 436: skipped unexpected token: T2\nWarning: \"mapToParameterTheory.maude\", line 436: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 436: skipped unexpected token: M\nWarning: \"mapToParameterTheory.maude\", line 436: skipped unexpected token: {\nWarning: \"mapToParameterTheory.maude\", line 436: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 436: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 436: skipped unexpected token: is\nWarning: \"mapToParameterTheory.maude\", line 437: skipped unexpected token: Elt2\nWarning: \"mapToParameterTheory.maude\", line 437: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 437: skipped unexpected token:\n    A$Elt\nWarning: \"mapToParameterTheory.maude\", line 438: syntax error\nWarning: \"mapToParameterTheory.maude\", line 438: skipped unexpected token: sum\nWarning: \"mapToParameterTheory.maude\", line 438: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 438: skipped unexpected token: +\nWarning: \"mapToParameterTheory.maude\", line 439: skipped unexpected token: endv\nWarning: \"mapToParameterTheory.maude\", line 460 (fmod TEST): syntax error\nWarning: \"mapToParameterTheory.maude\", line 488: syntax error\nWarning: \"mapToParameterTheory.maude\", line 488: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 488: skipped unexpected token: ::\nWarning: \"mapToParameterTheory.maude\", line 488: skipped unexpected token: T\nWarning: \"mapToParameterTheory.maude\", line 488: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 488: skipped unexpected token: from\nWarning: \"mapToParameterTheory.maude\", line 488: skipped unexpected token: T2\nWarning: \"mapToParameterTheory.maude\", line 488: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 488: skipped unexpected token: M\nWarning: \"mapToParameterTheory.maude\", line 488: skipped unexpected token: {\nWarning: \"mapToParameterTheory.maude\", line 488: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 488: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 488: skipped unexpected token: is\nWarning: \"mapToParameterTheory.maude\", line 489: skipped unexpected token: Elt2\nWarning: \"mapToParameterTheory.maude\", line 489: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 489: skipped unexpected token:\n    A$Elt\nWarning: \"mapToParameterTheory.maude\", line 490: syntax error\nWarning: \"mapToParameterTheory.maude\", line 490: skipped unexpected token: sum\nWarning: \"mapToParameterTheory.maude\", line 490: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 490: skipped unexpected token: +\nWarning: \"mapToParameterTheory.maude\", line 491: skipped unexpected token: endv\nWarning: \"mapToParameterTheory.maude\", line 512 (fmod TEST): syntax error\nWarning: \"mapToParameterTheory.maude\", line 545: syntax error\nWarning: \"mapToParameterTheory.maude\", line 545: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 545: skipped unexpected token: ::\nWarning: \"mapToParameterTheory.maude\", line 545: skipped unexpected token: T\nWarning: \"mapToParameterTheory.maude\", line 545: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 545: skipped unexpected token: from\nWarning: \"mapToParameterTheory.maude\", line 545: skipped unexpected token: T2\nWarning: \"mapToParameterTheory.maude\", line 545: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 545: skipped unexpected token: M\nWarning: \"mapToParameterTheory.maude\", line 545: skipped unexpected token: {\nWarning: \"mapToParameterTheory.maude\", line 545: skipped unexpected token: A\nWarning: \"mapToParameterTheory.maude\", line 545: skipped unexpected token: }\nWarning: \"mapToParameterTheory.maude\", line 545: skipped unexpected token: is\nWarning: \"mapToParameterTheory.maude\", line 546: skipped unexpected token: Elt2\nWarning: \"mapToParameterTheory.maude\", line 546: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 546: skipped unexpected token:\n    A$Elt\nWarning: \"mapToParameterTheory.maude\", line 547: syntax error\nWarning: \"mapToParameterTheory.maude\", line 547: skipped unexpected token: f2\nWarning: \"mapToParameterTheory.maude\", line 547: skipped unexpected token: to\nWarning: \"mapToParameterTheory.maude\", line 547: skipped unexpected token: f\nWarning: \"mapToParameterTheory.maude\", line 548: skipped unexpected token: endv\nWarning: \"mapToParameterTheory.maude\", line 572 (fmod TEST): syntax error\nWarning: \"mapToParameterTheory.maude\", line 577: bad token p.\nWarning: \"mapToParameterTheory.maude\", line 577: no parse for term.\nWarning: \"mapToParameterTheory-command\", line 4: bad token run.\nWarning: \"mapToParameterTheory-command\", line 4: no parse for term.\nWarning: \"mapToParameterTheory-command\", line 5: bad token initials.\nWarning: \"mapToParameterTheory-command\", line 5: no parse for term.",
                0.6299843788146973
            ]
        ]
    },
    {
        "file": "MAUDE-1/metaApplyNov2018.maude",
        "logic": "---\n\n### Protocol Description\n\n#### Overview\nThis protocol defines a simple algebraic structure involving two sorts, `Foo` and `Bar`, where `Foo` is a subsort of `Bar`. The protocol includes operations for manipulating elements of these sorts and describes the relationship between them through equations and rewrite rules.\n\n#### Sorts\n- **Foo**: A basic sort representing a subset of elements.\n- **Bar**: A broader sort that encompasses elements of `Foo`.\n\n#### Operations\n- **Constants**:\n  - `a`: An element of sort `Bar`.\n  - `c`: Another element of sort `Bar`.\n  \n- **Function**:\n  - `b`: A constant element of sort `Foo`.\n  \n- **Binary Operation**:\n  - `f`: A commutative binary operation that takes two arguments of sort `Foo` and returns a result of sort `Foo`.\n\n#### Equations\n- The protocol includes the equation `a = c`, indicating that the constants `a` and `c` are considered equivalent within the context of this protocol.\n\n#### Meta-Level Behavior\n- The protocol utilizes meta-level constructs to manage applications of the function `f`:\n  - **Meta-Apply**: This operation applies the function `f` to the arguments `a` and `b`, producing a result in the meta-level context. The application is labeled with `k`.\n  - **Meta-Xapply**: This operation extends the application to include additional parameters, demonstrating the capability to manage more complex scenarios in the meta-level context.\n\n#### Rewrite Rules\n- The rewrite rule `rl f(X:Foo, Y:Foo) => X:Foo` indicates that when the function `f` is applied to two elements of sort `Foo`, the result is simply the first argument, `X`.\n\n#### Meta-Reduction\nThe protocol specifies two reduction operations that can be performed within the meta-level:\n1. `metaApply(['APPLY], 'f['a.Foo, 'b.Foo], 'k, 'Y:Foo <- 'b.Foo, 0)`: This operation applies the function `f` to the elements `a` and `b`, tracking the application with label `k`.\n2. `metaXapply(['APPLY], 'f['a.Foo, 'b.Foo], 'k, 'Y:Foo <- 'b.Foo, 0, 0, 0)`: This operation similarly applies `f` but includes additional parameters for more complex processing.\n\n### Conclusion\nThis protocol is structured to demonstrate basic algebraic operations with elements of different sorts and the handling of these operations at the meta-level. The use of equations, operations, and rewrite rules allows for a flexible and extensible approach to protocol definition.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 13:20:57 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in META-LEVEL : metaApply(['APPLY], 'f['a.Foo,'b.Foo], 'k, \n\t'Y:Foo <- 'b.Foo, 0) .\nrewrites: 7\nmb applications: 2  equational rewrites: 4  rule rewrites: 1  variant narrowing\n    steps: 0  narrowing steps: 0\nresult ResultTriple: {'c.Foo,'Foo,\n\t'X:Foo <- 'c.Foo ; \n\t'Y:Foo <- 'b.Foo}\n==========================================\nreduce in META-LEVEL : metaXapply(['APPLY], 'f['a.Foo,'b.Foo], 'k, \n\t'Y:Foo <- 'b.Foo, 0, 0, 0) .\nrewrites: 7\nmb applications: 2  equational rewrites: 4  rule rewrites: 1  variant narrowing\n    steps: 0  narrowing steps: 0\nresult Result4Tuple: {'c.Foo,'Foo,\n\t'X:Foo <- 'c.Foo ; \n\t'Y:Foo <- 'b.Foo,[]}\nBye.Warning: \"metaApplyNov2018-command\", line 4: bad token run.\nWarning: \"metaApplyNov2018-command\", line 4: no parse for term.\nWarning: \"metaApplyNov2018-command\", line 5: bad token initials.\nWarning: \"metaApplyNov2018-command\", line 5: no parse for term.",
                0.6283037662506104
            ]
        ]
    },
    {
        "file": "MAUDE-1/metaAutoOoIncludeFebruary2023.maude",
        "logic": "---\n\n## Description of the Protocol\n\n### Protocol Name: Testing Object-Oriented Inclusion in Maude\n\n### Objective\nThe primary aim of this protocol is to test and verify that automatically included object-oriented components are reflected in the unflattened results when utilizing the `upModule()` functionality in the Maude-NPA (Network Protocol Analyzer) tool.\n\n### Components\n1. **Object Declaration**:\n   - An object named `FOO` is defined with no specific attributes or behaviors, serving as a placeholder for demonstrating the inclusion of object-oriented structures.\n\n2. **Module Reductions**:\n   - The protocol utilizes the `red` command to perform reductions in the `META-LEVEL` module. Specifically, it calls the `upModule()` function with the parameters `'FOO` and `false`. This function is expected to process the `FOO` object and check whether its properties and structures are appropriately included in the output.\n\n### Execution\n- The command `set show timing off` is employed to disable timing information in the output, focusing solely on the structural results of the `upModule()` function call.\n\n### Expected Outcome\nUpon executing the protocol, the results from `upModule('FOO, false)` should demonstrate that the object-oriented features of `FOO` are included as expected in the unflattened representation. This will validate the functionality of the Maude-NPA tool in handling object-oriented constructs.\n\n---\n\n### Corresponding Maude File\n\nBased on the above description, the corresponding Maude file that can be run in Maude-NPA would look like this:\n\n```maude\nset show timing off .\n\n***\n***\tTesting Object-Oriented Inclusion in Maude\n***\n\noth FOO is\nendoth\n\nred in META-LEVEL : upModule('FOO, false) .\n```",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 10:19:04 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in META-LEVEL : upModule('FOO, false) .\nrewrites: 0\nresult [Module]: upModule('FOO, false)\nBye.Warning: \"metaAutoOoIncludeFebruary2023.maude\", line 7: skipped unexpected\n    token: oth\nWarning: \"metaAutoOoIncludeFebruary2023.maude\", line 7: skipped unexpected\n    token: FOO\nWarning: \"metaAutoOoIncludeFebruary2023.maude\", line 7: skipped unexpected\n    token: is\nWarning: \"metaAutoOoIncludeFebruary2023.maude\", line 8: skipped unexpected\n    token: endoth\nWarning: \"metaAutoOoIncludeFebruary2023-command\", line 4: bad token run.\nWarning: \"metaAutoOoIncludeFebruary2023-command\", line 4: no parse for term.\nWarning: \"metaAutoOoIncludeFebruary2023-command\", line 5: bad token initials.\nWarning: \"metaAutoOoIncludeFebruary2023-command\", line 5: no parse for term.",
                0.5769860744476318
            ]
        ]
    },
    {
        "file": "MAUDE-1/metaIntMatchOct2018.maude",
        "logic": "---\n\n### Protocol Description\n\n#### Overview\nThe protocol implements a system to match and compare objects of different types using a specific set of operations and rules. It utilizes a meta-level matching mechanism to facilitate interactions between different modules.\n\n#### Modules\n1. **MATCH**: This is the primary module that defines the sorts and operations used for matching. It includes:\n   - **Sorts**: \n     - `Foo`: A subtype of `Bar`.\n     - `Bar`: A general type for objects involved in matching.\n   - **Operations**:\n     - `f`: A commutative binary operation on `Bar`.\n     - `g` and `h`: Functions that operate on `Foo`.\n     - Constants `a`, `b`, `c`, `d`, and `e` of sort `Foo`.\n   - **Equations**: \n     - Define relationships between `g` and `h` with certain constants to establish the conditions under which matches can occur.\n   - **Combinations**: \n     - A combination rule that defines how the operation `f` can be applied based on the results of `g` and `h`.\n\n2. **MATCH-TEST**: This module tests the matching functionality.\n   - **Operations**:\n     - `me`: Represents a unique identifier for the user.\n     - `User`: Represents the user type.\n     - `soln:_`: An attribute used to represent solutions (results of match operations).\n   - **Rules**:\n     - When an interpreter is created, the matching module is inserted into the interpreter context.\n     - Upon module insertion, the `getMatch` function is invoked to find matches for given parameters.\n\n3. **XMATCH-TEST**: Similar to `MATCH-TEST`, this module focuses on extended matching.\n   - **Rules**:\n     - Similar to `MATCH-TEST`, but it invokes the `getXmatch` function, which handles extended match queries.\n\n#### Execution\n- The system begins by creating an interpreter instance that initializes the matching context.\n- Initially, the solution count is set to zero.\n- The matching operations (`metaMatch` and `metaXmatch`) are executed to explore the relationships defined in the `MATCH` module.\n\n#### Functional Requirements\n- The protocol ensures that matching operations do not count the same computations multiple times.\n- It uses a meta-level approach to facilitate the matching process, allowing for both standard and extended matching queries.\n\n#### Evaluation\n- The protocol can be evaluated using the Maude-NPA tool, which supports the execution of the above modules and their interactions.\n- The results of the matching processes can be observed through the defined output attributes.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Thu May 22 12:25:48 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nreduce in META-LEVEL : metaMatch(['MATCH], 'Z:Foo, 'f['a.Foo,'c.Foo], nil, 0) .\nrewrites: 8\nmb applications: 2  equational rewrites: 6  rule rewrites: 0  variant narrowing\n    steps: 0  narrowing steps: 0\nresult Assignment: \n\t'Z:Foo <- 'f['a.Foo,'c.Foo]\n==========================================\nreduce in META-LEVEL : metaXmatch(['MATCH], 'Z:Foo, 'f['a.Foo,'c.Foo], nil, 0,\n    unbounded, 0) .\nrewrites: 8\nmb applications: 2  equational rewrites: 6  rule rewrites: 0  variant narrowing\n    steps: 0  narrowing steps: 0\nresult MatchPair: {\n\t'Z:Foo <- 'f['a.Foo,'c.Foo],[]}\nBye.Warning: \"metaIntMatchOct2018.maude\", line 35: unable to locate file:\n    metaInterpreter\nWarning: \"metaIntMatchOct2018.maude\", line 37 (mod MATCH-TEST): module\n    META-INTERPRETER does not exist.\nWarning: \"metaIntMatchOct2018.maude\", line 39 (mod MATCH-TEST): undeclared sort\n    Oid.\nWarning: \"metaIntMatchOct2018.maude\", line 40 (mod MATCH-TEST): undeclared sort\n    Cid.\nWarning: \"metaIntMatchOct2018.maude\", line 41 (mod MATCH-TEST): undeclared sort\n    Nat.\nWarning: \"metaIntMatchOct2018.maude\", line 41 (mod MATCH-TEST): undeclared sort\n    Attribute.\nWarning: \"metaIntMatchOct2018.maude\", line 44 (mod MATCH-TEST): undeclared sort\n    AttributeSet.\nWarning: \"metaIntMatchOct2018.maude\", line 47 (mod MATCH-TEST): bad token <.\nWarning: \"metaIntMatchOct2018.maude\", line 47 (mod MATCH-TEST): no parse for\n    statement\nrl < X : User | AS > createdInterpreter (X, Y, Z) => < X : User | AS >\n    insertModule (Z, X, upModule ('MATCH, true)) .\nWarning: \"metaIntMatchOct2018.maude\", line 50 (mod MATCH-TEST): bad token <.\nWarning: \"metaIntMatchOct2018.maude\", line 50 (mod MATCH-TEST): no parse for\n    statement\nrl < X : User | soln: N, AS > insertedModule (X, Y) => < X : User | AS >\n    getMatch (Y, X, 'MATCH, 'Z:Foo, 'f ['a.Foo, 'c.Foo], nil, N) .\nWarning: \"metaIntMatchOct2018.maude\", line 54: bad token <>.\nWarning: \"metaIntMatchOct2018.maude\", line 54: no parse for term.\nWarning: \"metaIntMatchOct2018.maude\", line 60 (mod XMATCH-TEST): module\n    META-INTERPRETER does not exist.\nWarning: \"metaIntMatchOct2018.maude\", line 62 (mod XMATCH-TEST): undeclared\n    sort Oid.\nWarning: \"metaIntMatchOct2018.maude\", line 63 (mod XMATCH-TEST): undeclared\n    sort Cid.\nWarning: \"metaIntMatchOct2018.maude\", line 64 (mod XMATCH-TEST): undeclared\n    sort Nat.\nWarning: \"metaIntMatchOct2018.maude\", line 64 (mod XMATCH-TEST): undeclared\n    sort Attribute.\nWarning: \"metaIntMatchOct2018.maude\", line 67 (mod XMATCH-TEST): undeclared\n    sort AttributeSet.\nWarning: \"metaIntMatchOct2018.maude\", line 70 (mod XMATCH-TEST): bad token <.\nWarning: \"metaIntMatchOct2018.maude\", line 70 (mod XMATCH-TEST): no parse for\n    statement\nrl < X : User | AS > createdInterpreter (X, Y, Z) => < X : User | AS >\n    insertModule (Z, X, upModule ('MATCH, true)) .\nWarning: \"metaIntMatchOct2018.maude\", line 73 (mod XMATCH-TEST): bad token <.\nWarning: \"metaIntMatchOct2018.maude\", line 73 (mod XMATCH-TEST): no parse for\n    statement\nrl < X : User | soln: N, AS > insertedModule (X, Y) => < X : User | AS >\n    getXmatch (Y, X, 'MATCH, 'Z:Foo, 'f ['a.Foo, 'c.Foo], nil, 0, unbounded, N)\n    .\nWarning: \"metaIntMatchOct2018.maude\", line 77: bad token <>.\nWarning: \"metaIntMatchOct2018.maude\", line 77: no parse for term.\nWarning: \"metaIntMatchOct2018-command\", line 4: bad token run.\nWarning: \"metaIntMatchOct2018-command\", line 4: no parse for term.\nWarning: \"metaIntMatchOct2018-command\", line 5: bad token initials.\nWarning: \"metaIntMatchOct2018-command\", line 5: no parse for term.",
                0.6785824298858643
            ]
        ]
    },
    {
        "file": "MAUDE-1/multiset-algebra.maude",
        "logic": "### Protocol Description\n\n#### Overview\nThis protocol defines a formal framework for manipulating multisets of natural numbers. A multiset allows for the representation of collections where elements can appear multiple times, differing from a standard set where each element is unique. The operations defined include multiset union, intersection, difference, containment, membership, cardinality, and distinct element counting.\n\n#### Elements\n1. **Natural Numbers**: The protocol operates on natural numbers, where `0` is defined as the base element, and `s(N)` denotes the successor function, representing natural numbers greater than `0`.\n\n2. **Multisets**: The fundamental structure is the multiset, which can contain elements of type `Nat`. The operations defined allow for the construction and manipulation of these multisets.\n\n#### Operations\n- **Construction**:\n  - `mt`: Represents the empty multiset.\n  - `_,_`: The operator for multiset union, allowing the combination of two multisets.\n\n- **Set Operations**:\n  - `\\`: Multiset difference, which removes elements of one multiset from another.\n  - `C=`: Multiset containment, which checks if all elements of one multiset are present in another.\n  - `in`: Membership operator, checking if an element belongs to a multiset.\n  - `/\\`: Multiset intersection, yielding a new multiset containing only the common elements.\n\n- **Cardinality**:\n  - `|_|`: Calculates the total count of elements in a multiset, considering repetitions.\n  - `[_]`: Counts the number of distinct elements in a multiset.\n\n- **Element Removal**:\n  - `rem`: Removes all occurrences of a specified element from a multiset.\n\n- **Equality**:\n  - The protocol defines equality between multisets based on their contents, ensuring that two multisets are equal if they contain the same elements in the same multiplicities.\n\n#### Properties\nSeveral equations are defined to ensure the consistency and properties of the operations:\n- Operations such as union, intersection, and difference follow specific algebraic rules.\n- The definition ensures that operations behave identically regardless of the order of the multisets (commutativity and associativity).\n- Special cases are handled, like the empty multiset behaving neutrally in operations.\n\n#### Examples\nThe protocol includes several reduction examples to demonstrate the expected behavior of operations:\n- Checking containment and membership of elements in multisets.\n- Performing multiset union and difference operations.\n- Verifying the cardinality and distinct counts of multisets.\n\n### Conclusion\nThis protocol lays the groundwork for performing algebraic operations on multisets of natural numbers within a formal system. It is suitable for applications that require mathematical guarantees about the behavior of collections of elements, such as in cryptographic protocols and formal verification systems.\n\n### Maude File Generation\nWith this description, you can generate a corresponding Maude file that implements the operations and properties as described, ensuring it can be executed in the Maude-NPA environment. The file should include all the defined sorts, operations, equations, and reduction examples to validate the functionality of the multiset algebra.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 23:29:34 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"multiset-algebra-command\", line 4: bad token run.\nWarning: \"multiset-algebra-command\", line 4: no parse for term.\nWarning: \"multiset-algebra-command\", line 5: bad token initials.\nWarning: \"multiset-algebra-command\", line 5: no parse for term.",
                0.678563117980957
            ]
        ]
    },
    {
        "file": "MAUDE-1/numbers-ACU-proofs.maude",
        "logic": "---\n\n### Protocol Description\n\n**Protocol Name:** Rational Number Arithmetic with GCD Properties\n\n**Overview:**\nThis protocol defines a framework for manipulating rational numbers within the context of an arithmetic system that emphasizes properties of the greatest common divisor (gcd). The focus is on properties of natural numbers and their interactions, particularly in terms of division and negation.\n\n**Key Constructs:**\n1. **Variables:**\n   - `N'`, `M'`: These are variables representing non-zero natural numbers (NzNat).\n\n2. **Equations and Properties:**\n   - **GCD Definitions:**\n     - `gcd(1, N') = 1`: The gcd of 1 and any natural number is always 1.\n     - `gcd(N', M') > 1 = tt`: This expression states that if the gcd of two natural numbers is greater than 1, it evaluates to true (tt).\n   - **Quotients and Negations:**\n     - `quot(N', 1) = N'`: Any number divided by 1 is itself.\n     - `-(I:Int / J:Int) = -I:Int / J:Int`: The negative of a fraction is equal to the negative of the numerator divided by the denominator.\n     - `- - I:Int = I:Int`: The double negation of an integer reverts to the original integer.\n\n**Rewrite Rules:**\nThe protocol showcases several rewrite rules that demonstrate key properties of rational numbers and their gcd:\n1. **First Rewrite Rule:**\n   - `-(quot(1, gcd(@2:NzNat, 1)) / quot(@2:NzNat, gcd(@2:NzNat, 1))) == -1 / @2:NzNat`\n   - This rule simplifies the fraction involving gcd and confirms that it evaluates to true.\n\n2. **Second Rewrite Rule:**\n   - `-(quot(N':NzNat + M':NzNat, gcd(@2:NzNat, N':NzNat + M':NzNat)) / quot(@2:NzNat, gcd(@2:NzNat, N':NzNat + M':NzNat))) == -(N':NzNat + M':NzNat) / @2:NzNat`\n   - This rule illustrates how the sum of two natural numbers interacts with their gcd.\n\n3. **Third Rewrite Rule:**\n   - `-(quot(-N':NzNat, gcd(@2:NzNat, -N':NzNat)) / quot(@2:NzNat, gcd(@2:NzNat, -N':NzNat))) == -(-N':NzNat) / @2:NzNat`\n   - This rule shows the relationship between the negation of a number and its gcd.\n\n**Conclusion:**\nThis protocol effectively models rational number operations while highlighting the essential properties of gcd in arithmetic. It provides a foundation for further exploration of number theory within the framework of the Maude-NPA tool, allowing for rigorous proofs and evaluations of mathematical statements.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 22:48:12 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"numbers-ACU-proofs.maude\", line 9 (fmod PROOFS): didn't expect token\n    I:Int:\neq - ( I:Int / J:Int ) = - I:Int <---*HERE*\nWarning: \"numbers-ACU-proofs.maude\", line 9 (fmod PROOFS): no parse for\n    statement\neq - (I:Int / J:Int) = - I:Int / J:Int .\nWarning: \"numbers-ACU-proofs.maude\", line 10 (fmod PROOFS): didn't expect token\n    -:\neq - - <---*HERE*\nWarning: \"numbers-ACU-proofs.maude\", line 10 (fmod PROOFS): no parse for\n    statement\neq - - I:Int = I:Int .\nWarning: \"numbers-ACU-proofs-command\", line 4: bad token run.\nWarning: \"numbers-ACU-proofs-command\", line 4: no parse for term.\nWarning: \"numbers-ACU-proofs-command\", line 5: bad token initials.\nWarning: \"numbers-ACU-proofs-command\", line 5: no parse for term.",
                0.6807413101196289
            ]
        ]
    },
    {
        "file": "MAUDE-1/objectMessageOct2018.maude",
        "logic": "---\n\n### Protocol Description\n\nThis protocol is designed to demonstrate the handling of object-message rewriting in the context of a system that employs user and object identifiers. The primary focus is on ensuring that fake rewrites of messages are correctly ignored by the debugging and profiling mechanisms.\n\n#### Key Components:\n1. **Modules and Inheritance**:\n   - The protocol is encapsulated within a module named `FOO`, which inherits from the `CONFIGURATION` module, indicating that it utilizes the configuration settings and structures defined therein.\n\n2. **Operators**:\n   - `User`: Represents a user identified by a unique identifier of type `Cid`.\n   - `me` and `other`: Represent object identifiers of type `Oid`, where `me` likely refers to the current user or entity executing the protocol, and `other` refers to another entity or object within the system.\n   - `no-op`: A message operation defined as taking two object identifiers and returning a message of type `Msg`. This operation is used to simulate a message that does nothing (a no-operation).\n\n3. **Variables**:\n   - `X` and `Y`: These are variables of type `Oid`, used to represent different object identifiers during rewrites.\n   - `AS`: An `AttributeSet` variable that can store various attributes associated with a user or an operation.\n\n4. **Rewrite Rules**:\n   - A rewrite rule is defined that states when a user (represented by `X`) sends a `no-op` message (with identifiers `X` and `Y`), the state remains unchanged. This showcases that the system ignores the no-operation message and retains the same user state.\n\n5. **Debugging and Profiling**:\n   - The debugging environment is configured to enable breakpoints and tracing. A specific breakpoint is set on the selection of the `__` operation.\n   - The tracing feature is activated to provide insight into the operation of the protocol, and profiling is enabled to analyze performance metrics during execution.\n\n6. **Fake Rewrites**:\n   - The protocol includes a fake rewrite operation that simulates a `no-op` message being sent from the user represented by `me` to the `other` object identifier. This is expected to trigger the debugger once, as the rewrite rule should effectively ignore the operation.\n\n7. **Execution Control**:\n   - After setting the breakpoints and enabling tracing, the protocol resumes execution. It concludes with a command to display the profiling information gathered during the protocol execution.\n\n### Summary\nThe protocol is structured to validate that the system's behavior remains consistent when handling specific message types, particularly no-operation messages. The use of debugging and profiling tools allows for monitoring and ensuring that the rewrite mechanisms function as expected, ignoring irrelevant or fake operations.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 17:50:31 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\n==========================================\nfrewrite in FOO : no-op(me, other) < me : User | none > .\nbreak on symbol: __\nrewrites: 1\nresult Object: < me : User | none >\nrl no-op(X, Y) < X : User | AS > => < X : User | AS > .\nrewrites: 1 (100%)\n\nBye.Warning: \"objectMessageOct2018-command\", line 4: bad token run.\nWarning: \"objectMessageOct2018-command\", line 4: no parse for term.\nWarning: \"objectMessageOct2018-command\", line 5: bad token initials.\nWarning: \"objectMessageOct2018-command\", line 5: no parse for term.",
                0.5772836208343506
            ]
        ]
    },
    {
        "file": "MAUDE-1/opRenamingParseErrorMarch2023.maude",
        "logic": "---\n\n### Description of the Protocol\n\nThis protocol is structured using the Maude language, and it demonstrates the use of sorts and operations with a specific focus on renaming operations using a custom sort. The protocol is divided into two modules: `FOO` and `BAR`.\n\n#### Module `FOO`\n- **Purpose**: The `FOO` module defines a new sort and an operation that utilizes this sort.\n- **Sorts**:\n  - `Foo`: A custom sort that represents a specific type of data or entity within the protocol.\n  - `to`: Another custom sort used to facilitate the renaming of operations.\n  \n- **Operations**:\n  - `f`: This is a function that takes an argument of type `Foo to` and produces an output of type `Foo`. The operation `f` is designed to manipulate or transform data that is structured in the `Foo to` sort.\n\n#### Module `BAR`\n- **Purpose**: The `BAR` module extends the functionality of the `FOO` module by including an operation that further utilizes the `f` operation defined in `FOO`.\n- **Inclusion**: It includes the `FOO` module, thereby inheriting its sorts and operations. \n- **Operations**:\n  - `g`: An additional operation is defined that operates on the `Foo to` sort, producing a result of type `Foo to`. This operation likely represents a transformation or processing step that is specifically tailored for the `Foo to` type.\n\n#### Functionality\nThe Maude-NPA tool is utilized to demonstrate that the operation renaming using the `to` sort parses correctly. The command `show desugared` is included to display the desugared syntax of the modules, providing insight into how the operations and sorts are interpreted by the Maude system.\n\n---\n\n### Corresponding Maude File\nThe description allows us to generate the corresponding Maude file, which is already provided in your initial input. Here\u2019s the Maude code again for reference:\n\n```maude\n*** Test that an op renaming using the sort \"to\" parses correctly. ***\n\nfmod FOO is\n  sorts Foo to .\n  op f : Foo to -> Foo .\nendfm\n\nfmod BAR is\n  inc FOO * (op f : Foo to -> Foo to g) .\nendfm\n\nshow desugared .\n```",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 21:21:46 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nBye.Warning: \"opRenamingParseErrorMarch2023.maude\", line 14: skipped unexpected\n    token: desugared\nWarning: \"opRenamingParseErrorMarch2023.maude\", line 14: syntax error\nWarning: \"opRenamingParseErrorMarch2023-command\", line 4: bad token run.\nWarning: \"opRenamingParseErrorMarch2023-command\", line 4: no parse for term.\nWarning: \"opRenamingParseErrorMarch2023-command\", line 5: bad token initials.\nWarning: \"opRenamingParseErrorMarch2023-command\", line 5: no parse for term.",
                0.7285187244415283
            ]
        ]
    },
    {
        "file": "MAUDE-1/operatorNames.maude",
        "logic": "---\n\n### Protocol Description\n\n#### Overview\nThis protocol defines a set of mathematical and operational constructs using the Maude language. It demonstrates the use of sorts, operations, and views to facilitate the manipulation of elements within different contexts.\n\n#### Components\n\n1. **Sorts and Operations in T and M**:\n   - The first module `T` defines a sort called `Elt` which is used to represent elements. Several operations are defined for this sort:\n     - `({_}:{_})`: A binary operator that combines two `Elt` elements.\n     - `{_}to{_}`: A binary operator that transforms two `Elt` elements into another `Elt`.\n     - `two to`: A constant operation that generates a specific `Elt`.\n     - `[:]: A nullary operation that generates an `Elt`.\n\n   - The second module `M` also defines the sort `Elt` and introduces new operations:\n     - `term{_,_}`: A binary operation on `Elt`.\n     - `{_}.{_}`: Another binary operation on `Elt`.\n     - `term{}`: A nullary operation that produces an `Elt`.\n     - `}. {`: A nullary operation producing an `Elt`.\n\n2. **View V**:\n   - A view `V` is established to connect operations from module `T` to module `M`. This allows for transformations between the two modules:\n     - The operation `({_}:{_})` in `T` is mapped to `term{_,_}` in `M`.\n     - The operation `{_}to{_}` is mapped to `.{_}.{_}`.\n     - The constant `two to` is mapped to `term{}`.\n     - The operation `[:]` is mapped to `}.{`.\n\n3. **Extended Definitions in T2**:\n   - A second theory `T2` builds upon `T` and includes additional operations that map to different constructs in the context of abstract data types.\n\n4. **Miscellaneous Modules**:\n   - Additional modules such as `OP-HOOK-TEST`, `OP-HOOK-TEST2`, and `FOO` introduce new sorts and operations, demonstrating the flexibility of Maude in handling various data types and operational semantics.\n   - For example, `OP-HOOK-TEST` defines natural numbers, zero, and operations for addition with hooks for processing.\n\n5. **Encapsulation and Structure**:\n   - The use of `fmod` (formal module) and `fth` (formal theory) encapsulates definitions, providing a structured approach to defining operations and their relationships.\n   - `omod` (open module) allows for the inclusion of operations and sorts from other modules, promoting code reuse.\n\n#### Conclusion\nThis protocol effectively illustrates how to define sorts, operations, and views in Maude, allowing for flexible manipulation of mathematical constructs. It serves as a foundation for more complex protocols and operational semantics in cryptographic and distributed systems analysis.\n\n---",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 13:21:05 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nfth T is\n  sorts Elt .\n  op `{_`}:`{_`} : Elt Elt -> Elt .\n  op `{_`}to`{_`} : Elt Elt -> Elt .\n  op two`to : -> Elt .\n  op `[:`] : -> Elt .\nendfth\nfmod M is\n  sorts Elt .\n  op term`{_`,_`} : Elt Elt -> Elt .\n  op `{_`}.`{_`} : Elt Elt -> Elt .\n  op term`{`} : -> Elt .\n  op `}.`{ : -> Elt .\nendfm\nview V from T to M is\n  op `{_`}:`{_`} to term`{_`,_`} .\n  op `{_`}to`{_`} to `{_`}.`{_`} .\n  op two`to to term`{`} .\n  op `[:`] to `}.`{ .\nendv\nview V from T to M is\n  op `{_`}:`{_`} to term`{_`,_`} .\n  op `{_`}to`{_`} to `{_`}.`{_`} .\n  op two`to to term`{`} .\n  op `[:`] to `}.`{ .\nendv\nfth T2 is\n  inc T * (op `{_`}:`{_`} to f`[_`,_`], op `{_`}to`{_`} to _`,_, op two`to to\n    `]`[, op `[:`] to `]i`[) .\nendfth\nfmod BOOL\nfmod TRUTH-VALUE\nfmod BOOL-OPS\nfmod TRUTH\nfmod EXT-BOOL\nfmod NAT\nfmod INT\nfmod RAT\nfmod M\nfmod FLOAT\nfmod STRING\nfmod CONVERSION\nfmod RANDOM\nfmod QID\nfth TRIV\nfth STRICT-WEAK-ORDER\nfth STRICT-TOTAL-ORDER\nfth TOTAL-PREORDER\nfth TOTAL-ORDER\nfth DEFAULT\nfmod LIST\nfmod WEAKLY-SORTABLE-LIST\nfmod SORTABLE-LIST\nfmod WEAKLY-SORTABLE-LIST'\nfmod SORTABLE-LIST'\nfmod SET\nfmod LIST-AND-SET\nfmod SORTABLE-LIST-AND-SET\nfmod SORTABLE-LIST-AND-SET'\nfmod LIST*\nfmod SET*\nfmod MAP\nfmod ARRAY\nfmod NAT-LIST\nfmod QID-LIST\nfmod QID-SET\nfmod META-TERM\nfmod META-MODULE\nfth T\nfmod META-VIEW\nfmod META-LEVEL\nmod COUNTER\nmod LOOP-MODE\nmod CONFIGURATION\nfmod BANNER-MAUDENPA\nfmod META-LEVEL-MNPA\nfmod UNIFICATIONTRIPLE\nfmod TERM-HANDLING\nfmod SUBSTITUTION-HANDLING\nfth T2\nfmod TERMSET\nfmod RENAMING\nfmod SUBSTITUTIONSET\nfmod UNIFICATIONPAIRSET\nfmod UNIFICATIONTRIPLESET\nfmod MODULE-HANDLING\nfmod VARIANT\nfmod META-MINIMIZE-BINDINGS\nfmod TYPEOFNARROWING\nfmod IRR-FLAGS\nfmod EFLAGS\nfmod RESULT-CONTEXT-SET\nfmod META-MATCH\nfmod VARIANT-HANDLING\nfmod RIGIDIFE\nfmod META-E-UNIFICATION\nfmod META-ACU-UNIFICATION\nfmod META-UNIFICATION\nfmod HEunification\nfmod XorUnif\nfmod AsyXorUnif\nfmod CHECKXOR\nfmod META-MSG-UNIFICATION-INTEGRATION\nfmod META-MSG-UNIFICATION\nfmod ORDERS-TERM-SUBSTITUTION\nfmod META-NORMALIZE\nfmod META-E-NARROWING\nfmod META-NARROWING-SEARCH\nfmod DEFINITION-PROTOCOL-RULES\nfmod GLOBAL-STRATEGY\nfmod DEFINITION-CONSTRAINTS\nfmod PROTOCOL-EXAMPLE-SYMBOLS\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC\nfmod PROTOCOL-SPECIFICATION\nmod STRAND-GENERAL-RULES\nmod COMPOSITION-RULES\nmod STRAND-EXAMPLE-RULES\nmod PROTOCOL-EXAMPLE-RULES\nmod STRAND-GENERAL-RULES-INPUT\nmod STRAND-EXAMPLE-RULES-INPUT\nfmod DEFINITION-CONSTRAINTS-HANDLING\nmod PROTOCOL-EXAMPLE-SYMBOLS-WITH-CONSTRAINT-SYMBOLS\nfmod DEFINITION-PROTOCOL-RULES-HANDLING\nfmod PROTOCOL-EXAMPLE-SYMBOLS-WITH-CONSTRAINT-SYMBOLS-HANDLING\nmod STRAND-EXAMPLE-RULES-WITH-ALL\nfmod DEFINITION-PROTOCOL-RULES-INPUT\nfmod DEFINITION-CONSTRAINTS-INPUT\nmod PROTOCOL-EXAMPLE-RULES-WITH-CONSTRAINT-SYMBOLS\nmod STRAND-EXAMPLE-RULES-WITH-DOLEVYAO-RULES-WITH-CONSTRAINT-SYMBOLS\nmod STRAND-EXAMPLE-RULES-WITH-DOLEVYAO-RULES-WITH-CONSTRAINT-SYMBOLS-METATERM\nfmod PROTOCOL-EXAMPLE-GHOST\nfmod GENERATE-RULES\nfmod RESULT-GRAMMAR-NARROWING\nfmod CONSTRAINTS-RULES\nfmod MEMBERSHIP-GRAMMAR-LANGUAGE\nfmod GRAMMAR-RULE-EXPANDABLE-TEST\nfmod GRAMMAR-NARROWING\nfmod GRAMMAR-HEURISTICS\nfmod GENERATION-CONSTRAINTS-RULES\nfmod GENERATION-NEW-GRAMMAR\nfmod OPTIMIZE-NEW-GRAMMAR\nfmod GRAMMAR-GENERATION\nfmod NEW-NEVER-PATTERNS-HANDLING\nfmod BACK-NARROWING\nfmod BACKWARDS-REACHABILITY\nfmod GENERIC-TOOLS\nmod MAUDE-NPA\nfth X :: TRIV\nfth X :: STRICT-WEAK-ORDER\nfmod LIST{STRICT-WEAK-ORDER}\nfmod LIST{STRICT-WEAK-ORDER}{[X]}\nfmod LIST{STRICT-WEAK-ORDER}{[X]} * (sort NeList{STRICT-WEAK-ORDER}{X} to\n    NeList{X}, sort List{STRICT-WEAK-ORDER}{X} to List{X})\nfth X :: STRICT-TOTAL-ORDER\nfmod WEAKLY-SORTABLE-LIST{STRICT-TOTAL-ORDER}\nfmod LIST{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}\nfmod LIST{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]}\nfmod LIST{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]} * (sort NeList{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to NeList{STRICT-TOTAL-ORDER}{X},\n    sort List{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to List{\n    STRICT-TOTAL-ORDER}{X})\nfmod WEAKLY-SORTABLE-LIST{STRICT-TOTAL-ORDER}{[X]}\nfmod WEAKLY-SORTABLE-LIST{STRICT-TOTAL-ORDER}{[X]} * (sort NeList{\n    STRICT-TOTAL-ORDER}{X} to NeList{X}, sort List{STRICT-TOTAL-ORDER}{X} to\n    List{X})\nfmod LIST{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]} * (sort NeList{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to NeList{STRICT-TOTAL-ORDER}{X},\n    sort List{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to List{\n    STRICT-TOTAL-ORDER}{X}) * (sort NeList{STRICT-TOTAL-ORDER}{X} to NeList{X},\n    sort List{STRICT-TOTAL-ORDER}{X} to List{X})\nfth X :: TOTAL-PREORDER\nfmod LIST{TOTAL-PREORDER}\nfmod LIST{TOTAL-PREORDER}{[X]}\nfmod LIST{TOTAL-PREORDER}{[X]} * (sort NeList{TOTAL-PREORDER}{X} to NeList{X},\n    sort List{TOTAL-PREORDER}{X} to List{X})\nfth X :: TOTAL-ORDER\nfmod WEAKLY-SORTABLE-LIST'{TOTAL-ORDER}\nfmod LIST{TOTAL-PREORDER}{TOTAL-ORDER}\nfmod LIST{TOTAL-PREORDER}{TOTAL-ORDER}{[X]}\nfmod LIST{TOTAL-PREORDER}{TOTAL-ORDER}{[X]} * (sort NeList{TOTAL-PREORDER}{\n    TOTAL-ORDER}{X} to NeList{TOTAL-ORDER}{X}, sort List{TOTAL-PREORDER}{\n    TOTAL-ORDER}{X} to List{TOTAL-ORDER}{X})\nfmod WEAKLY-SORTABLE-LIST'{TOTAL-ORDER}{[X]}\nfmod WEAKLY-SORTABLE-LIST'{TOTAL-ORDER}{[X]} * (sort NeList{TOTAL-ORDER}{X} to\n    NeList{X}, sort List{TOTAL-ORDER}{X} to List{X})\nfmod LIST{TOTAL-PREORDER}{TOTAL-ORDER}{[X]} * (sort NeList{TOTAL-PREORDER}{\n    TOTAL-ORDER}{X} to NeList{TOTAL-ORDER}{X}, sort List{TOTAL-PREORDER}{\n    TOTAL-ORDER}{X} to List{TOTAL-ORDER}{X}) * (sort NeList{TOTAL-ORDER}{X} to\n    NeList{X}, sort List{TOTAL-ORDER}{X} to List{X})\nfmod LIST{[X]}\nfmod SET{[X]}\nfmod SORTABLE-LIST{[X]}\nfmod LIST-AND-SET{STRICT-WEAK-ORDER}\nfmod SET{STRICT-WEAK-ORDER}\nfmod SET{STRICT-WEAK-ORDER}{[X]}\nfmod LIST-AND-SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}\nfmod SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}\nfmod SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]}\nfmod LIST-AND-SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]}\nfmod LIST-AND-SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]} * (sort NeList{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to NeList{STRICT-TOTAL-ORDER}{X},\n    sort List{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to List{\n    STRICT-TOTAL-ORDER}{X})\nfmod LIST-AND-SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]} * (sort NeList{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to NeList{STRICT-TOTAL-ORDER}{X},\n    sort List{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to List{\n    STRICT-TOTAL-ORDER}{X}) * (sort NeList{STRICT-TOTAL-ORDER}{X} to NeList{X},\n    sort List{STRICT-TOTAL-ORDER}{X} to List{X}, sort NeSet{STRICT-WEAK-ORDER}{\n    STRICT-TOTAL-ORDER}{X} to NeSet{X}, sort Set{STRICT-WEAK-ORDER}{\n    STRICT-TOTAL-ORDER}{X} to Set{X})\nfmod SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]} * (sort NeSet{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to NeSet{X}, sort Set{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to Set{X})\nfmod SORTABLE-LIST'{[X]}\nfmod LIST-AND-SET{TOTAL-PREORDER}\nfmod SET{TOTAL-PREORDER}\nfmod SET{TOTAL-PREORDER}{[X]}\nfmod LIST-AND-SET{TOTAL-PREORDER}{TOTAL-ORDER}\nfmod SET{TOTAL-PREORDER}{TOTAL-ORDER}\nfmod SET{TOTAL-PREORDER}{TOTAL-ORDER}{[X]}\nfmod LIST-AND-SET{TOTAL-PREORDER}{TOTAL-ORDER}{[X]}\nfmod LIST-AND-SET{TOTAL-PREORDER}{TOTAL-ORDER}{[X]} * (sort NeList{\n    TOTAL-PREORDER}{TOTAL-ORDER}{X} to NeList{TOTAL-ORDER}{X}, sort List{\n    TOTAL-PREORDER}{TOTAL-ORDER}{X} to List{TOTAL-ORDER}{X})\nfmod LIST-AND-SET{TOTAL-PREORDER}{TOTAL-ORDER}{[X]} * (sort NeList{\n    TOTAL-PREORDER}{TOTAL-ORDER}{X} to NeList{TOTAL-ORDER}{X}, sort List{\n    TOTAL-PREORDER}{TOTAL-ORDER}{X} to List{TOTAL-ORDER}{X}) * (sort NeList{\n    TOTAL-ORDER}{X} to NeList{X}, sort List{TOTAL-ORDER}{X} to List{X}, sort\n    NeSet{TOTAL-PREORDER}{TOTAL-ORDER}{X} to NeSet{X}, sort Set{\n    TOTAL-PREORDER}{TOTAL-ORDER}{X} to Set{X})\nfmod SET{TOTAL-PREORDER}{TOTAL-ORDER}{[X]} * (sort NeSet{TOTAL-PREORDER}{\n    TOTAL-ORDER}{X} to NeSet{X}, sort Set{TOTAL-PREORDER}{TOTAL-ORDER}{X} to\n    Set{X})\nfth Y :: TRIV\nfth Y :: DEFAULT\nfmod LIST{Nat}\nfmod LIST{Nat} * (sort NeList{Nat} to NeNatList, sort List{Nat} to NatList)\nfmod LIST{Qid}\nfmod LIST{Qid} * (sort NeList{Qid} to NeQidList, sort List{Qid} to QidList)\nfmod SET{Qid}\nfmod SET{Qid} * (sort NeSet{Qid} to NeQidSet, sort Set{Qid} to QidSet)\nfmod QID-SET * (op _`,_ to _;_ [prec 43], op empty to none)\nfmod SET{Qid} * (sort NeSet{Qid} to NeQidSet, sort Set{Qid} to QidSet) * (op\n    _`,_ to _;_ [prec 43], op empty to none)\nfmod AsyXorUnif * (sort Problem to ProblemXOR, op GenNewVar`(_`,_`) to\n    GenNewVarXOR`(_`,_`), op _~_ to _~XOR_)\nfmod XorUnif * (sort Problem to ProblemXOR, op GenNewVar`(_`,_`) to\n    GenNewVarXOR`(_`,_`))\nfmod HEunification * (sort Problem to ProblemHE, op GenNewVar`(_`,_`) to\n    GenNewVarHE`(_`,_`), op HasHomomorphism to IsMetaHEUnify, op\n    Solve`(_`,_`,_`) to metaHEUnify, op _#_ to _HE#_, op getTypeHomomorphism to\n    getTypeHomoUnify)\nmod LOOP-MODE * (sort System to System-Loop)\nfth T * (op `[:`] to `]i`[, op `{_`}:`{_`} to f`[_`,_`], op `{_`}to`{_`} to\n    _`,_, op two`to to `]`[)\nview Bool\nview Nat\nview Int\nview Rat\nview Float\nview String\nview Qid\nview TRIV\nview STRICT-WEAK-ORDER\nview STRICT-TOTAL-ORDER\nview Nat<\nview Int<\nview Rat<\nview Float<\nview String<\nview TOTAL-PREORDER\nview TOTAL-ORDER\nview Nat<=\nview Int<=\nview Rat<=\nview Float<=\nview String<=\nview DEFAULT\nview Nat0\nview Int0\nview Rat0\nview Float0\nview String0\nview Qid0\nview V\nview V from T to M is\n  op `{_`}:`{_`} to term`{_`,_`} .\n  op `{_`}to`{_`} to `{_`}.`{_`} .\n  op two`to to term`{`} .\n  op `[:`] to `}.`{ .\nendv\nview V from T to M is\n  op `{_`}:`{_`} to term`{_`,_`} .\n  op `{_`}to`{_`} to `{_`}.`{_`} .\n  op two`to to term`{`} .\n  op `[:`] to `}.`{ .\nendv\nfmod OP-HOOK-TEST2 is\n  sorts Bool Zero NzNat Nat .\n  subsorts Zero NzNat < Nat .\n  op if_then_else_fi : Bool Universal Universal -> Universal [poly (2 3 0) prec\n    0 gather (& & &) special (\n    id-hook BranchSymbol\n    term-hook 1 (true)\n    term-hook 2 (false))] .\n  op _==_ : Universal Universal -> Bool [poly (1 2) prec 51 gather (E E)\n    special (\n    id-hook EqualitySymbol\n    term-hook equalTerm (true)\n    term-hook notEqualTerm (false))] .\n  op _=/=_ : Universal Universal -> Bool [poly (1 2) prec 51 gather (E E)\n    special (\n    id-hook EqualitySymbol\n    term-hook equalTerm (false)\n    term-hook notEqualTerm (true))] .\n  op true : -> Bool [ctor special (\n    id-hook SystemTrue)] .\n  op false : -> Bool [ctor special (\n    id-hook SystemFalse)] .\n  op _and_ : Bool Bool -> Bool [assoc comm prec 55 gather (e E)] .\n  op _or_ : Bool Bool -> Bool [assoc comm prec 59 gather (e E)] .\n  op _xor_ : Bool Bool -> Bool [assoc comm prec 57 gather (e E)] .\n  op not_ : Bool -> Bool [prec 53 gather (E)] .\n  op _implies_ : Bool Bool -> Bool [prec 61 gather (e E)] .\n  op 0 : -> Zero [ctor] .\n  op : : Nat -> NzNat [ctor iter special (\n    id-hook SuccSymbol\n    term-hook zeroTerm (0))] .\n  op _+_ : NzNat Nat -> NzNat [assoc comm prec 33 gather (e E) special (\n    id-hook ACU_NumberOpSymbol (+)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _+_ : Nat Nat -> Nat [assoc comm prec 33 gather (e E) special (\n    id-hook ACU_NumberOpSymbol (+)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op sd : Nat Nat -> Nat [comm special (\n    id-hook CUI_NumberOpSymbol (sd)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _*_ : NzNat NzNat -> NzNat [assoc comm prec 31 gather (e E) special (\n    id-hook ACU_NumberOpSymbol (*)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _*_ : Nat Nat -> Nat [assoc comm prec 31 gather (e E) special (\n    id-hook ACU_NumberOpSymbol (*)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _quo_ : Nat NzNat -> Nat [prec 31 gather (E e) special (\n    id-hook NumberOpSymbol (quo)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _rem_ : Nat NzNat -> Nat [prec 31 gather (E e) special (\n    id-hook NumberOpSymbol (rem)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _^_ : Nat Nat -> Nat [prec 29 gather (E e) special (\n    id-hook NumberOpSymbol (^)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _^_ : NzNat Nat -> NzNat [prec 29 gather (E e) special (\n    id-hook NumberOpSymbol (^)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op modExp : [Nat] [Nat] [Nat] -> [Nat] [special (\n    id-hook NumberOpSymbol (modExp)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op gcd : NzNat Nat -> NzNat [assoc comm special (\n    id-hook ACU_NumberOpSymbol (gcd)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op gcd : Nat Nat -> Nat [assoc comm special (\n    id-hook ACU_NumberOpSymbol (gcd)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op lcm : NzNat NzNat -> NzNat [assoc comm special (\n    id-hook ACU_NumberOpSymbol (lcm)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op lcm : Nat Nat -> Nat [assoc comm special (\n    id-hook ACU_NumberOpSymbol (lcm)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op min : NzNat NzNat -> NzNat [assoc comm special (\n    id-hook ACU_NumberOpSymbol (min)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op min : Nat Nat -> Nat [assoc comm special (\n    id-hook ACU_NumberOpSymbol (min)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op max : NzNat Nat -> NzNat [assoc comm special (\n    id-hook ACU_NumberOpSymbol (max)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op max : Nat Nat -> Nat [assoc comm special (\n    id-hook ACU_NumberOpSymbol (max)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _xor_ : Nat Nat -> Nat [assoc comm prec 55 gather (e E) special (\n    id-hook ACU_NumberOpSymbol (xor)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _&_ : Nat Nat -> Nat [assoc comm prec 53 gather (e E) special (\n    id-hook ACU_NumberOpSymbol (&)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _|_ : NzNat Nat -> NzNat [assoc comm prec 57 gather (e E) special (\n    id-hook ACU_NumberOpSymbol (|)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _|_ : Nat Nat -> Nat [assoc comm prec 57 gather (e E) special (\n    id-hook ACU_NumberOpSymbol (|)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _>>_ : Nat Nat -> Nat [prec 35 gather (E e) special (\n    id-hook NumberOpSymbol (>>)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _<<_ : Nat Nat -> Nat [prec 35 gather (E e) special (\n    id-hook NumberOpSymbol (<<)\n    op-hook succSymbol (: : Nat ~> NzNat))] .\n  op _<_ : Nat Nat -> Bool [prec 37 gather (E E) special (\n    id-hook NumberOpSymbol (<)\n    op-hook succSymbol (: : Nat ~> NzNat)\n    term-hook trueTerm (true)\n    term-hook falseTerm (false))] .\n  op _<=_ : Nat Nat -> Bool [prec 37 gather (E E) special (\n    id-hook NumberOpSymbol (<=)\n    op-hook succSymbol (: : Nat ~> NzNat)\n    term-hook trueTerm (true)\n    term-hook falseTerm (false))] .\n  op _>_ : Nat Nat -> Bool [prec 37 gather (E E) special (\n    id-hook NumberOpSymbol (>)\n    op-hook succSymbol (: : Nat ~> NzNat)\n    term-hook trueTerm (true)\n    term-hook falseTerm (false))] .\n  op _>=_ : Nat Nat -> Bool [prec 37 gather (E E) special (\n    id-hook NumberOpSymbol (>=)\n    op-hook succSymbol (: : Nat ~> NzNat)\n    term-hook trueTerm (true)\n    term-hook falseTerm (false))] .\n  op _divides_ : NzNat Nat -> Bool [prec 51 gather (E E) special (\n    id-hook NumberOpSymbol (divides)\n    op-hook succSymbol (: : Nat ~> NzNat)\n    term-hook trueTerm (true)\n    term-hook falseTerm (false))] .\n  eq true and A:Bool = A:Bool .\n  eq false and A:Bool = false .\n  eq A:Bool and A:Bool = A:Bool .\n  eq false xor A:Bool = A:Bool .\n  eq A:Bool xor A:Bool = false .\n  eq A:Bool and (B:Bool xor C:Bool) = A:Bool and B:Bool xor A:Bool and C:Bool .\n  eq not A:Bool = true xor A:Bool .\n  eq A:Bool or B:Bool = A:Bool and B:Bool xor A:Bool xor B:Bool .\n  eq A:Bool implies B:Bool = not (A:Bool xor A:Bool and B:Bool) .\nendfm\nmod FOO is\n  sorts Foo Bar .\n  ops f `[_`] : Foo -> Foo .\n  ops m `[_`] : Bar -> Msg [msg] .\nendm\nfmod FOO is\n  sorts Foo .\n  ops `[_`] : : Foo -> Foo .\nendfm\nBye.Warning: \"operatorNames.maude\", line 36: skipped unexpected token: desugared\nWarning: \"operatorNames.maude\", line 36: skipped unexpected token: T\nWarning: \"operatorNames.maude\", line 36: syntax error\nWarning: \"operatorNames.maude\", line 38: skipped unexpected token: desugared\nWarning: \"operatorNames.maude\", line 38: skipped unexpected token: M\nWarning: \"operatorNames.maude\", line 38: syntax error\nWarning: \"operatorNames.maude\", line 40: skipped unexpected token: processed\nWarning: \"operatorNames.maude\", line 42: skipped unexpected token: desugared\nWarning: \"operatorNames.maude\", line 42: skipped unexpected token: T2\nWarning: \"operatorNames.maude\", line 42: syntax error\nWarning: \"operatorNames.maude\", line 52: syntax error\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: X\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: ::\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: TRIV\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: }\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: from\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: T\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: *\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: _\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: ,\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: _\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: to\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: {\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: _\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: ,\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: _\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: }\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: to\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: LIST\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: {\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: X\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: }\nWarning: \"operatorNames.maude\", line 52: skipped unexpected token: is\nWarning: \"operatorNames.maude\", line 53: skipped unexpected token: Elt\nWarning: \"operatorNames.maude\", line 53: skipped unexpected token: to\nWarning: \"operatorNames.maude\", line 53: skipped unexpected token: List\nWarning: \"operatorNames.maude\", line 53: skipped unexpected token: {\nWarning: \"operatorNames.maude\", line 53: skipped unexpected token: X\nWarning: \"operatorNames.maude\", line 53: skipped unexpected token: }\nWarning: \"operatorNames.maude\", line 54: syntax error\nWarning: \"operatorNames.maude\", line 54: skipped unexpected token: {\nWarning: \"operatorNames.maude\", line 54: skipped unexpected token: _\nWarning: \"operatorNames.maude\", line 54: skipped unexpected token: ,\nWarning: \"operatorNames.maude\", line 54: skipped unexpected token: _\nWarning: \"operatorNames.maude\", line 54: skipped unexpected token: }\nWarning: \"operatorNames.maude\", line 54: skipped unexpected token: to\nWarning: \"operatorNames.maude\", line 54: skipped unexpected token: append\nWarning: \"operatorNames.maude\", line 55: skipped unexpected token: endv\nWarning: \"operatorNames.maude\", line 58: skipped unexpected token: processed\nWarning: \"operatorNames.maude\", line 71 (fmod OP-HOOK-TEST): bad special for\n    operator _+_.\nWarning: \"operatorNames.maude\", line 60 (fmod OP-HOOK-TEST): this module\n    contains one or more errors that could not be patched up and thus it cannot\n    be used or imported.\nWarning: \"operatorNames.maude\", line 60 (fmod OP-HOOK-TEST): module\n    OP-HOOK-TEST is unusable due to unpatchable errors.\nWarning: \"operatorNames.maude\", line 79: skipped unexpected token: desugared\nWarning: \"operatorNames.maude\", line 79: syntax error\nWarning: \"operatorNames.maude\", line 90 (omod FOO): undeclared sort Msg.\nWarning: \"operatorNames-command\", line 4: bad token run.\nWarning: \"operatorNames-command\", line 4: no parse for term.\nWarning: \"operatorNames-command\", line 5: bad token initials.\nWarning: \"operatorNames-command\", line 5: no parse for term.",
                0.6279151439666748
            ]
        ]
    },
    {
        "file": "MAUDE-1/orphanedViewInstantiationFebruary2023.maude",
        "logic": "Based on the provided Maude file content, the description content of the protocol can be articulated as follows:\n\n---\n\n### Protocol Description: Garbage Collection of Orphaned View Instantiation\n\n**Objective:**\nThis protocol tests the garbage collection mechanism for orphaned view instantiations in a Maude-NPA (Narrative Protocol Analysis) environment.\n\n**Modules:**\n- **FOO**: This is the main module that incorporates the necessary libraries and definitions required for the protocol execution.\n\n**Included Libraries:**\n- **LIST{Set{Nat}}**: This library is being included to provide functionalities for managing lists and sets of natural numbers. This inclusion indicates that the protocol may involve operations related to sets and lists, possibly for managing sessions or states within the protocol.\n\n**Structure:**\n1. **Module Declaration**:\n   - The `fmod` keyword is used to define a module named `FOO`.\n   - The `inc` keyword is utilized to include the `LIST{Set{Nat}}` library, which provides essential data structures and operations.\n\n2. **Empty Module Declaration**:\n   - A second `fmod` declaration of the same module `FOO` is made, but it is currently empty. This part of the code suggests that the module might be intended for further development or testing of specific properties, such as garbage collection for orphaned views.\n\n**Commands**:\n- `show modules .`: This command displays the current modules within the Maude environment.\n- `show views .`: This command displays the views that have been defined in the current session.\n\n### Purpose:\nThe purpose of this Maude file is to create a framework for testing the garbage collection of orphaned view instantiations. It sets up a basic environment with necessary libraries while also providing a structure for future enhancements or specific tests related to memory management and view instantiation in the Maude-NPA system.\n\n---\n\n### Corresponding Maude File Generation:\n\nTo generate a Maude file that can be run by Maude-NPA based on the description, it would look like the following:\n\n```maude\n*** Test that orphaned view instantiation is garbage collected. ***\n\nfmod FOO is\n  inc LIST{Set{Nat}} .\nendfm\n\nshow modules .\nshow views .\n```\n\nThis generated Maude file precisely reflects the structure and intent of the original Maude content, enabling it to be executed in the Maude-NPA environment for the intended purpose of testing garbage collection mechanisms.",
        "results": [
            true,
            [
                true,
                "\\||||||||||||||||||/\n\t\t   --- Welcome to Maude ---\n\t\t     /||||||||||||||||||\\\n\t    Maude 2.7++ built: Sep  9 2014 14:55:11\n\t    With additional hooks \n\t    Copyright 1997-2014 SRI International\n\t\t   Wed May 21 18:59:15 2025\n\n\t    Maude-NPA Version:  March 12th 2015\n\t    with direct composition and irreducibility constraints\n\t    (To be run with Maude alpha104 or above)\n\t    Copyright (c) 2015, University of Illinois\n\t    All rights reserved.\n\n Commands:\n red unification? .           for getting the unification algorithm\n red genGrammars .            for generating grammars\n red run(X,Y).                for Y backwards analysis steps for attack pattern\n    X\n red summary(X,Y).            for summary of analysis steps\n red initials(X,Y).           for showing only initial steps\nfmod BOOL\nfmod TRUTH-VALUE\nfmod BOOL-OPS\nfmod TRUTH\nfmod EXT-BOOL\nfmod NAT\nfmod INT\nfmod RAT\nfmod FLOAT\nfmod STRING\nfmod CONVERSION\nfmod RANDOM\nfmod QID\nfth TRIV\nfth STRICT-WEAK-ORDER\nfth STRICT-TOTAL-ORDER\nfth TOTAL-PREORDER\nfth TOTAL-ORDER\nfth DEFAULT\nfmod LIST\nfmod WEAKLY-SORTABLE-LIST\nfmod SORTABLE-LIST\nfmod WEAKLY-SORTABLE-LIST'\nfmod SORTABLE-LIST'\nfmod SET\nfmod LIST-AND-SET\nfmod SORTABLE-LIST-AND-SET\nfmod SORTABLE-LIST-AND-SET'\nfmod LIST*\nfmod SET*\nfmod MAP\nfmod ARRAY\nfmod NAT-LIST\nfmod QID-LIST\nfmod QID-SET\nfmod META-TERM\nfmod META-MODULE\nfmod META-VIEW\nfmod META-LEVEL\nmod COUNTER\nmod LOOP-MODE\nmod CONFIGURATION\nfmod BANNER-MAUDENPA\nfmod META-LEVEL-MNPA\nfmod UNIFICATIONTRIPLE\nfmod TERM-HANDLING\nfmod SUBSTITUTION-HANDLING\nfmod TERMSET\nfmod RENAMING\nfmod SUBSTITUTIONSET\nfmod UNIFICATIONPAIRSET\nfmod UNIFICATIONTRIPLESET\nfmod MODULE-HANDLING\nfmod VARIANT\nfmod META-MINIMIZE-BINDINGS\nfmod TYPEOFNARROWING\nfmod IRR-FLAGS\nfmod EFLAGS\nfmod RESULT-CONTEXT-SET\nfmod META-MATCH\nfmod VARIANT-HANDLING\nfmod RIGIDIFE\nfmod META-E-UNIFICATION\nfmod META-ACU-UNIFICATION\nfmod META-UNIFICATION\nfmod HEunification\nfmod XorUnif\nfmod AsyXorUnif\nfmod CHECKXOR\nfmod META-MSG-UNIFICATION-INTEGRATION\nfmod META-MSG-UNIFICATION\nfmod ORDERS-TERM-SUBSTITUTION\nfmod META-NORMALIZE\nfmod META-E-NARROWING\nfmod META-NARROWING-SEARCH\nfmod DEFINITION-PROTOCOL-RULES\nfmod GLOBAL-STRATEGY\nfmod DEFINITION-CONSTRAINTS\nfmod PROTOCOL-EXAMPLE-SYMBOLS\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC\nfmod PROTOCOL-SPECIFICATION\nmod STRAND-GENERAL-RULES\nmod COMPOSITION-RULES\nmod STRAND-EXAMPLE-RULES\nmod PROTOCOL-EXAMPLE-RULES\nmod STRAND-GENERAL-RULES-INPUT\nmod STRAND-EXAMPLE-RULES-INPUT\nfmod DEFINITION-CONSTRAINTS-HANDLING\nmod PROTOCOL-EXAMPLE-SYMBOLS-WITH-CONSTRAINT-SYMBOLS\nfmod DEFINITION-PROTOCOL-RULES-HANDLING\nfmod PROTOCOL-EXAMPLE-SYMBOLS-WITH-CONSTRAINT-SYMBOLS-HANDLING\nmod STRAND-EXAMPLE-RULES-WITH-ALL\nfmod DEFINITION-PROTOCOL-RULES-INPUT\nfmod DEFINITION-CONSTRAINTS-INPUT\nmod PROTOCOL-EXAMPLE-RULES-WITH-CONSTRAINT-SYMBOLS\nmod STRAND-EXAMPLE-RULES-WITH-DOLEVYAO-RULES-WITH-CONSTRAINT-SYMBOLS\nmod STRAND-EXAMPLE-RULES-WITH-DOLEVYAO-RULES-WITH-CONSTRAINT-SYMBOLS-METATERM\nfmod PROTOCOL-EXAMPLE-GHOST\nfmod GENERATE-RULES\nfmod RESULT-GRAMMAR-NARROWING\nfmod CONSTRAINTS-RULES\nfmod MEMBERSHIP-GRAMMAR-LANGUAGE\nfmod GRAMMAR-RULE-EXPANDABLE-TEST\nfmod GRAMMAR-NARROWING\nfmod GRAMMAR-HEURISTICS\nfmod GENERATION-CONSTRAINTS-RULES\nfmod GENERATION-NEW-GRAMMAR\nfmod OPTIMIZE-NEW-GRAMMAR\nfmod GRAMMAR-GENERATION\nfmod NEW-NEVER-PATTERNS-HANDLING\nfmod BACK-NARROWING\nfmod BACKWARDS-REACHABILITY\nfmod GENERIC-TOOLS\nmod MAUDE-NPA\nfmod FOO\nfth X :: TRIV\nfth X :: STRICT-WEAK-ORDER\nfmod LIST{STRICT-WEAK-ORDER}\nfmod LIST{STRICT-WEAK-ORDER}{[X]}\nfmod LIST{STRICT-WEAK-ORDER}{[X]} * (sort NeList{STRICT-WEAK-ORDER}{X} to\n    NeList{X}, sort List{STRICT-WEAK-ORDER}{X} to List{X})\nfth X :: STRICT-TOTAL-ORDER\nfmod WEAKLY-SORTABLE-LIST{STRICT-TOTAL-ORDER}\nfmod LIST{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}\nfmod LIST{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]}\nfmod LIST{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]} * (sort NeList{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to NeList{STRICT-TOTAL-ORDER}{X},\n    sort List{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to List{\n    STRICT-TOTAL-ORDER}{X})\nfmod WEAKLY-SORTABLE-LIST{STRICT-TOTAL-ORDER}{[X]}\nfmod WEAKLY-SORTABLE-LIST{STRICT-TOTAL-ORDER}{[X]} * (sort NeList{\n    STRICT-TOTAL-ORDER}{X} to NeList{X}, sort List{STRICT-TOTAL-ORDER}{X} to\n    List{X})\nfmod LIST{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]} * (sort NeList{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to NeList{STRICT-TOTAL-ORDER}{X},\n    sort List{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to List{\n    STRICT-TOTAL-ORDER}{X}) * (sort NeList{STRICT-TOTAL-ORDER}{X} to NeList{X},\n    sort List{STRICT-TOTAL-ORDER}{X} to List{X})\nfth X :: TOTAL-PREORDER\nfmod LIST{TOTAL-PREORDER}\nfmod LIST{TOTAL-PREORDER}{[X]}\nfmod LIST{TOTAL-PREORDER}{[X]} * (sort NeList{TOTAL-PREORDER}{X} to NeList{X},\n    sort List{TOTAL-PREORDER}{X} to List{X})\nfth X :: TOTAL-ORDER\nfmod WEAKLY-SORTABLE-LIST'{TOTAL-ORDER}\nfmod LIST{TOTAL-PREORDER}{TOTAL-ORDER}\nfmod LIST{TOTAL-PREORDER}{TOTAL-ORDER}{[X]}\nfmod LIST{TOTAL-PREORDER}{TOTAL-ORDER}{[X]} * (sort NeList{TOTAL-PREORDER}{\n    TOTAL-ORDER}{X} to NeList{TOTAL-ORDER}{X}, sort List{TOTAL-PREORDER}{\n    TOTAL-ORDER}{X} to List{TOTAL-ORDER}{X})\nfmod WEAKLY-SORTABLE-LIST'{TOTAL-ORDER}{[X]}\nfmod WEAKLY-SORTABLE-LIST'{TOTAL-ORDER}{[X]} * (sort NeList{TOTAL-ORDER}{X} to\n    NeList{X}, sort List{TOTAL-ORDER}{X} to List{X})\nfmod LIST{TOTAL-PREORDER}{TOTAL-ORDER}{[X]} * (sort NeList{TOTAL-PREORDER}{\n    TOTAL-ORDER}{X} to NeList{TOTAL-ORDER}{X}, sort List{TOTAL-PREORDER}{\n    TOTAL-ORDER}{X} to List{TOTAL-ORDER}{X}) * (sort NeList{TOTAL-ORDER}{X} to\n    NeList{X}, sort List{TOTAL-ORDER}{X} to List{X})\nfmod LIST{[X]}\nfmod SET{[X]}\nfmod SORTABLE-LIST{[X]}\nfmod LIST-AND-SET{STRICT-WEAK-ORDER}\nfmod SET{STRICT-WEAK-ORDER}\nfmod SET{STRICT-WEAK-ORDER}{[X]}\nfmod LIST-AND-SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}\nfmod SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}\nfmod SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]}\nfmod LIST-AND-SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]}\nfmod LIST-AND-SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]} * (sort NeList{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to NeList{STRICT-TOTAL-ORDER}{X},\n    sort List{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to List{\n    STRICT-TOTAL-ORDER}{X})\nfmod LIST-AND-SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]} * (sort NeList{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to NeList{STRICT-TOTAL-ORDER}{X},\n    sort List{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to List{\n    STRICT-TOTAL-ORDER}{X}) * (sort NeList{STRICT-TOTAL-ORDER}{X} to NeList{X},\n    sort List{STRICT-TOTAL-ORDER}{X} to List{X}, sort NeSet{STRICT-WEAK-ORDER}{\n    STRICT-TOTAL-ORDER}{X} to NeSet{X}, sort Set{STRICT-WEAK-ORDER}{\n    STRICT-TOTAL-ORDER}{X} to Set{X})\nfmod SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]} * (sort NeSet{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to NeSet{X}, sort Set{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to Set{X})\nfmod SORTABLE-LIST'{[X]}\nfmod LIST-AND-SET{TOTAL-PREORDER}\nfmod SET{TOTAL-PREORDER}\nfmod SET{TOTAL-PREORDER}{[X]}\nfmod LIST-AND-SET{TOTAL-PREORDER}{TOTAL-ORDER}\nfmod SET{TOTAL-PREORDER}{TOTAL-ORDER}\nfmod SET{TOTAL-PREORDER}{TOTAL-ORDER}{[X]}\nfmod LIST-AND-SET{TOTAL-PREORDER}{TOTAL-ORDER}{[X]}\nfmod LIST-AND-SET{TOTAL-PREORDER}{TOTAL-ORDER}{[X]} * (sort NeList{\n    TOTAL-PREORDER}{TOTAL-ORDER}{X} to NeList{TOTAL-ORDER}{X}, sort List{\n    TOTAL-PREORDER}{TOTAL-ORDER}{X} to List{TOTAL-ORDER}{X})\nfmod LIST-AND-SET{TOTAL-PREORDER}{TOTAL-ORDER}{[X]} * (sort NeList{\n    TOTAL-PREORDER}{TOTAL-ORDER}{X} to NeList{TOTAL-ORDER}{X}, sort List{\n    TOTAL-PREORDER}{TOTAL-ORDER}{X} to List{TOTAL-ORDER}{X}) * (sort NeList{\n    TOTAL-ORDER}{X} to NeList{X}, sort List{TOTAL-ORDER}{X} to List{X}, sort\n    NeSet{TOTAL-PREORDER}{TOTAL-ORDER}{X} to NeSet{X}, sort Set{\n    TOTAL-PREORDER}{TOTAL-ORDER}{X} to Set{X})\nfmod SET{TOTAL-PREORDER}{TOTAL-ORDER}{[X]} * (sort NeSet{TOTAL-PREORDER}{\n    TOTAL-ORDER}{X} to NeSet{X}, sort Set{TOTAL-PREORDER}{TOTAL-ORDER}{X} to\n    Set{X})\nfth Y :: TRIV\nfth Y :: DEFAULT\nfmod LIST{Nat}\nfmod LIST{Nat} * (sort NeList{Nat} to NeNatList, sort List{Nat} to NatList)\nfmod LIST{Qid}\nfmod LIST{Qid} * (sort NeList{Qid} to NeQidList, sort List{Qid} to QidList)\nfmod SET{Qid}\nfmod SET{Qid} * (sort NeSet{Qid} to NeQidSet, sort Set{Qid} to QidSet)\nfmod QID-SET * (op _`,_ to _;_ [prec 43], op empty to none)\nfmod SET{Qid} * (sort NeSet{Qid} to NeQidSet, sort Set{Qid} to QidSet) * (op\n    _`,_ to _;_ [prec 43], op empty to none)\nfmod AsyXorUnif * (sort Problem to ProblemXOR, op GenNewVar`(_`,_`) to\n    GenNewVarXOR`(_`,_`), op _~_ to _~XOR_)\nfmod XorUnif * (sort Problem to ProblemXOR, op GenNewVar`(_`,_`) to\n    GenNewVarXOR`(_`,_`))\nfmod HEunification * (sort Problem to ProblemHE, op GenNewVar`(_`,_`) to\n    GenNewVarHE`(_`,_`), op HasHomomorphism to IsMetaHEUnify, op\n    Solve`(_`,_`,_`) to metaHEUnify, op _#_ to _HE#_, op getTypeHomomorphism to\n    getTypeHomoUnify)\nmod LOOP-MODE * (sort System to System-Loop)\nview Bool\nview Nat\nview Int\nview Rat\nview Float\nview String\nview Qid\nview TRIV\nview STRICT-WEAK-ORDER\nview STRICT-TOTAL-ORDER\nview Nat<\nview Int<\nview Rat<\nview Float<\nview String<\nview TOTAL-PREORDER\nview TOTAL-ORDER\nview Nat<=\nview Int<=\nview Rat<=\nview Float<=\nview String<=\nview DEFAULT\nview Nat0\nview Int0\nview Rat0\nview Float0\nview String0\nview Qid0\nfmod BOOL\nfmod TRUTH-VALUE\nfmod BOOL-OPS\nfmod TRUTH\nfmod EXT-BOOL\nfmod NAT\nfmod INT\nfmod RAT\nfmod FLOAT\nfmod STRING\nfmod CONVERSION\nfmod RANDOM\nfmod QID\nfth TRIV\nfth STRICT-WEAK-ORDER\nfth STRICT-TOTAL-ORDER\nfth TOTAL-PREORDER\nfth TOTAL-ORDER\nfth DEFAULT\nfmod LIST\nfmod WEAKLY-SORTABLE-LIST\nfmod SORTABLE-LIST\nfmod WEAKLY-SORTABLE-LIST'\nfmod SORTABLE-LIST'\nfmod SET\nfmod LIST-AND-SET\nfmod SORTABLE-LIST-AND-SET\nfmod SORTABLE-LIST-AND-SET'\nfmod LIST*\nfmod SET*\nfmod MAP\nfmod ARRAY\nfmod NAT-LIST\nfmod QID-LIST\nfmod QID-SET\nfmod META-TERM\nfmod META-MODULE\nfmod META-VIEW\nfmod META-LEVEL\nmod COUNTER\nmod LOOP-MODE\nmod CONFIGURATION\nfmod BANNER-MAUDENPA\nfmod META-LEVEL-MNPA\nfmod UNIFICATIONTRIPLE\nfmod TERM-HANDLING\nfmod SUBSTITUTION-HANDLING\nfmod TERMSET\nfmod RENAMING\nfmod SUBSTITUTIONSET\nfmod UNIFICATIONPAIRSET\nfmod UNIFICATIONTRIPLESET\nfmod MODULE-HANDLING\nfmod VARIANT\nfmod META-MINIMIZE-BINDINGS\nfmod TYPEOFNARROWING\nfmod IRR-FLAGS\nfmod EFLAGS\nfmod RESULT-CONTEXT-SET\nfmod META-MATCH\nfmod VARIANT-HANDLING\nfmod RIGIDIFE\nfmod META-E-UNIFICATION\nfmod META-ACU-UNIFICATION\nfmod META-UNIFICATION\nfmod HEunification\nfmod XorUnif\nfmod AsyXorUnif\nfmod CHECKXOR\nfmod META-MSG-UNIFICATION-INTEGRATION\nfmod META-MSG-UNIFICATION\nfmod ORDERS-TERM-SUBSTITUTION\nfmod META-NORMALIZE\nfmod META-E-NARROWING\nfmod META-NARROWING-SEARCH\nfmod DEFINITION-PROTOCOL-RULES\nfmod GLOBAL-STRATEGY\nfmod DEFINITION-CONSTRAINTS\nfmod PROTOCOL-EXAMPLE-SYMBOLS\nfmod PROTOCOL-EXAMPLE-ALGEBRAIC\nfmod PROTOCOL-SPECIFICATION\nmod STRAND-GENERAL-RULES\nmod COMPOSITION-RULES\nmod STRAND-EXAMPLE-RULES\nmod PROTOCOL-EXAMPLE-RULES\nmod STRAND-GENERAL-RULES-INPUT\nmod STRAND-EXAMPLE-RULES-INPUT\nfmod DEFINITION-CONSTRAINTS-HANDLING\nmod PROTOCOL-EXAMPLE-SYMBOLS-WITH-CONSTRAINT-SYMBOLS\nfmod DEFINITION-PROTOCOL-RULES-HANDLING\nfmod PROTOCOL-EXAMPLE-SYMBOLS-WITH-CONSTRAINT-SYMBOLS-HANDLING\nmod STRAND-EXAMPLE-RULES-WITH-ALL\nfmod DEFINITION-PROTOCOL-RULES-INPUT\nfmod DEFINITION-CONSTRAINTS-INPUT\nmod PROTOCOL-EXAMPLE-RULES-WITH-CONSTRAINT-SYMBOLS\nmod STRAND-EXAMPLE-RULES-WITH-DOLEVYAO-RULES-WITH-CONSTRAINT-SYMBOLS\nmod STRAND-EXAMPLE-RULES-WITH-DOLEVYAO-RULES-WITH-CONSTRAINT-SYMBOLS-METATERM\nfmod PROTOCOL-EXAMPLE-GHOST\nfmod GENERATE-RULES\nfmod RESULT-GRAMMAR-NARROWING\nfmod CONSTRAINTS-RULES\nfmod MEMBERSHIP-GRAMMAR-LANGUAGE\nfmod GRAMMAR-RULE-EXPANDABLE-TEST\nfmod GRAMMAR-NARROWING\nfmod GRAMMAR-HEURISTICS\nfmod GENERATION-CONSTRAINTS-RULES\nfmod GENERATION-NEW-GRAMMAR\nfmod OPTIMIZE-NEW-GRAMMAR\nfmod GRAMMAR-GENERATION\nfmod NEW-NEVER-PATTERNS-HANDLING\nfmod BACK-NARROWING\nfmod BACKWARDS-REACHABILITY\nfmod GENERIC-TOOLS\nmod MAUDE-NPA\nfmod FOO\nfth X :: TRIV\nfth X :: STRICT-WEAK-ORDER\nfmod LIST{STRICT-WEAK-ORDER}\nfmod LIST{STRICT-WEAK-ORDER}{[X]}\nfmod LIST{STRICT-WEAK-ORDER}{[X]} * (sort NeList{STRICT-WEAK-ORDER}{X} to\n    NeList{X}, sort List{STRICT-WEAK-ORDER}{X} to List{X})\nfth X :: STRICT-TOTAL-ORDER\nfmod WEAKLY-SORTABLE-LIST{STRICT-TOTAL-ORDER}\nfmod LIST{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}\nfmod LIST{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]}\nfmod LIST{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]} * (sort NeList{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to NeList{STRICT-TOTAL-ORDER}{X},\n    sort List{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to List{\n    STRICT-TOTAL-ORDER}{X})\nfmod WEAKLY-SORTABLE-LIST{STRICT-TOTAL-ORDER}{[X]}\nfmod WEAKLY-SORTABLE-LIST{STRICT-TOTAL-ORDER}{[X]} * (sort NeList{\n    STRICT-TOTAL-ORDER}{X} to NeList{X}, sort List{STRICT-TOTAL-ORDER}{X} to\n    List{X})\nfmod LIST{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]} * (sort NeList{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to NeList{STRICT-TOTAL-ORDER}{X},\n    sort List{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to List{\n    STRICT-TOTAL-ORDER}{X}) * (sort NeList{STRICT-TOTAL-ORDER}{X} to NeList{X},\n    sort List{STRICT-TOTAL-ORDER}{X} to List{X})\nfth X :: TOTAL-PREORDER\nfmod LIST{TOTAL-PREORDER}\nfmod LIST{TOTAL-PREORDER}{[X]}\nfmod LIST{TOTAL-PREORDER}{[X]} * (sort NeList{TOTAL-PREORDER}{X} to NeList{X},\n    sort List{TOTAL-PREORDER}{X} to List{X})\nfth X :: TOTAL-ORDER\nfmod WEAKLY-SORTABLE-LIST'{TOTAL-ORDER}\nfmod LIST{TOTAL-PREORDER}{TOTAL-ORDER}\nfmod LIST{TOTAL-PREORDER}{TOTAL-ORDER}{[X]}\nfmod LIST{TOTAL-PREORDER}{TOTAL-ORDER}{[X]} * (sort NeList{TOTAL-PREORDER}{\n    TOTAL-ORDER}{X} to NeList{TOTAL-ORDER}{X}, sort List{TOTAL-PREORDER}{\n    TOTAL-ORDER}{X} to List{TOTAL-ORDER}{X})\nfmod WEAKLY-SORTABLE-LIST'{TOTAL-ORDER}{[X]}\nfmod WEAKLY-SORTABLE-LIST'{TOTAL-ORDER}{[X]} * (sort NeList{TOTAL-ORDER}{X} to\n    NeList{X}, sort List{TOTAL-ORDER}{X} to List{X})\nfmod LIST{TOTAL-PREORDER}{TOTAL-ORDER}{[X]} * (sort NeList{TOTAL-PREORDER}{\n    TOTAL-ORDER}{X} to NeList{TOTAL-ORDER}{X}, sort List{TOTAL-PREORDER}{\n    TOTAL-ORDER}{X} to List{TOTAL-ORDER}{X}) * (sort NeList{TOTAL-ORDER}{X} to\n    NeList{X}, sort List{TOTAL-ORDER}{X} to List{X})\nfmod LIST{[X]}\nfmod SET{[X]}\nfmod SORTABLE-LIST{[X]}\nfmod LIST-AND-SET{STRICT-WEAK-ORDER}\nfmod SET{STRICT-WEAK-ORDER}\nfmod SET{STRICT-WEAK-ORDER}{[X]}\nfmod LIST-AND-SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}\nfmod SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}\nfmod SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]}\nfmod LIST-AND-SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]}\nfmod LIST-AND-SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]} * (sort NeList{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to NeList{STRICT-TOTAL-ORDER}{X},\n    sort List{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to List{\n    STRICT-TOTAL-ORDER}{X})\nfmod LIST-AND-SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]} * (sort NeList{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to NeList{STRICT-TOTAL-ORDER}{X},\n    sort List{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to List{\n    STRICT-TOTAL-ORDER}{X}) * (sort NeList{STRICT-TOTAL-ORDER}{X} to NeList{X},\n    sort List{STRICT-TOTAL-ORDER}{X} to List{X}, sort NeSet{STRICT-WEAK-ORDER}{\n    STRICT-TOTAL-ORDER}{X} to NeSet{X}, sort Set{STRICT-WEAK-ORDER}{\n    STRICT-TOTAL-ORDER}{X} to Set{X})\nfmod SET{STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{[X]} * (sort NeSet{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to NeSet{X}, sort Set{\n    STRICT-WEAK-ORDER}{STRICT-TOTAL-ORDER}{X} to Set{X})\nfmod SORTABLE-LIST'{[X]}\nfmod LIST-AND-SET{TOTAL-PREORDER}\nfmod SET{TOTAL-PREORDER}\nfmod SET{TOTAL-PREORDER}{[X]}\nfmod LIST-AND-SET{TOTAL-PREORDER}{TOTAL-ORDER}\nfmod SET{TOTAL-PREORDER}{TOTAL-ORDER}\nfmod SET{TOTAL-PREORDER}{TOTAL-ORDER}{[X]}\nfmod LIST-AND-SET{TOTAL-PREORDER}{TOTAL-ORDER}{[X]}\nfmod LIST-AND-SET{TOTAL-PREORDER}{TOTAL-ORDER}{[X]} * (sort NeList{\n    TOTAL-PREORDER}{TOTAL-ORDER}{X} to NeList{TOTAL-ORDER}{X}, sort List{\n    TOTAL-PREORDER}{TOTAL-ORDER}{X} to List{TOTAL-ORDER}{X})\nfmod LIST-AND-SET{TOTAL-PREORDER}{TOTAL-ORDER}{[X]} * (sort NeList{\n    TOTAL-PREORDER}{TOTAL-ORDER}{X} to NeList{TOTAL-ORDER}{X}, sort List{\n    TOTAL-PREORDER}{TOTAL-ORDER}{X} to List{TOTAL-ORDER}{X}) * (sort NeList{\n    TOTAL-ORDER}{X} to NeList{X}, sort List{TOTAL-ORDER}{X} to List{X}, sort\n    NeSet{TOTAL-PREORDER}{TOTAL-ORDER}{X} to NeSet{X}, sort Set{\n    TOTAL-PREORDER}{TOTAL-ORDER}{X} to Set{X})\nfmod SET{TOTAL-PREORDER}{TOTAL-ORDER}{[X]} * (sort NeSet{TOTAL-PREORDER}{\n    TOTAL-ORDER}{X} to NeSet{X}, sort Set{TOTAL-PREORDER}{TOTAL-ORDER}{X} to\n    Set{X})\nfth Y :: TRIV\nfth Y :: DEFAULT\nfmod LIST{Nat}\nfmod LIST{Nat} * (sort NeList{Nat} to NeNatList, sort List{Nat} to NatList)\nfmod LIST{Qid}\nfmod LIST{Qid} * (sort NeList{Qid} to NeQidList, sort List{Qid} to QidList)\nfmod SET{Qid}\nfmod SET{Qid} * (sort NeSet{Qid} to NeQidSet, sort Set{Qid} to QidSet)\nfmod QID-SET * (op _`,_ to _;_ [prec 43], op empty to none)\nfmod SET{Qid} * (sort NeSet{Qid} to NeQidSet, sort Set{Qid} to QidSet) * (op\n    _`,_ to _;_ [prec 43], op empty to none)\nfmod AsyXorUnif * (sort Problem to ProblemXOR, op GenNewVar`(_`,_`) to\n    GenNewVarXOR`(_`,_`), op _~_ to _~XOR_)\nfmod XorUnif * (sort Problem to ProblemXOR, op GenNewVar`(_`,_`) to\n    GenNewVarXOR`(_`,_`))\nfmod HEunification * (sort Problem to ProblemHE, op GenNewVar`(_`,_`) to\n    GenNewVarHE`(_`,_`), op HasHomomorphism to IsMetaHEUnify, op\n    Solve`(_`,_`,_`) to metaHEUnify, op _#_ to _HE#_, op getTypeHomomorphism to\n    getTypeHomoUnify)\nmod LOOP-MODE * (sort System to System-Loop)\nview Bool\nview Nat\nview Int\nview Rat\nview Float\nview String\nview Qid\nview TRIV\nview STRICT-WEAK-ORDER\nview STRICT-TOTAL-ORDER\nview Nat<\nview Int<\nview Rat<\nview Float<\nview String<\nview TOTAL-PREORDER\nview TOTAL-ORDER\nview Nat<=\nview Int<=\nview Rat<=\nview Float<=\nview String<=\nview DEFAULT\nview Nat0\nview Int0\nview Rat0\nview Float0\nview String0\nview Qid0\nBye.Warning: \"orphanedViewInstantiationFebruary2023.maude\", line 6 (fmod FOO):\n    syntax error\nWarning: \"orphanedViewInstantiationFebruary2023-command\", line 4: bad token\n    run.\nWarning: \"orphanedViewInstantiationFebruary2023-command\", line 4: no parse for\n    term.\nWarning: \"orphanedViewInstantiationFebruary2023-command\", line 5: bad token\n    initials.\nWarning: \"orphanedViewInstantiationFebruary2023-command\", line 5: no parse for\n    term.",
                0.6255397796630859
            ]
        ]
    }
]